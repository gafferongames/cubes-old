/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netStream.h"

using namespace net;

SUITE( NetStream )
{
	TEST( test_bit_packer_write_bits )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		BitPacker bitpacker( BitPacker::Write, buffer, sizeof(buffer) );

		bitpacker.WriteBits( 0xFFFFFFFF, 32 );
		CHECK( bitpacker.GetBits() == 32 );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( buffer[0] == 0xFF );
		CHECK( buffer[1] == 0xFF );
		CHECK( buffer[2] == 0xFF );
		CHECK( buffer[3] == 0xFF );
		CHECK( buffer[4] == 0x00 );

		bitpacker.WriteBits( 0x1111FFFF, 16 );
		CHECK( bitpacker.GetBits() == 32 + 16 );
		CHECK( bitpacker.GetBytes() == 6 );
		CHECK( buffer[0] == 0xFF );
		CHECK( buffer[1] == 0xFF );
		CHECK( buffer[2] == 0xFF );
		CHECK( buffer[3] == 0xFF );
		CHECK( buffer[4] == 0xFF );
		CHECK( buffer[5] == 0xFF );
		CHECK( buffer[6] == 0x00 );

		bitpacker.WriteBits( 0x111111FF, 8 );
		CHECK( bitpacker.GetBits() == 32 + 16 + 8 );
		CHECK( bitpacker.GetBytes() == 7 );
		CHECK( buffer[0] == 0xFF );
		CHECK( buffer[1] == 0xFF );
		CHECK( buffer[2] == 0xFF );
		CHECK( buffer[3] == 0xFF );
		CHECK( buffer[4] == 0xFF );
		CHECK( buffer[5] == 0xFF );
		CHECK( buffer[6] == 0xFF );
		CHECK( buffer[7] == 0x00 );
	}
	
	TEST( test_bit_packer_write_bits_odd )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		BitPacker bitpacker( BitPacker::Write, buffer, sizeof(buffer) );
		
		bitpacker.WriteBits( 0xFFFFFFFF, 9 );
		CHECK( bitpacker.GetBytes() == 2 );
		CHECK( bitpacker.GetBits() == 9 );
		
		bitpacker.WriteBits( 0xFFFFFFFF, 1 );
		CHECK( bitpacker.GetBytes() == 2 );
		CHECK( bitpacker.GetBits() == 9 + 1 );
		
		bitpacker.WriteBits( 0xFFFFFFFF, 11 );
		CHECK( bitpacker.GetBytes() == 3 );		
		CHECK( bitpacker.GetBits() == 9 + 1 + 11 );
		
		bitpacker.WriteBits( 0xFFFFFFFF, 6 );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( bitpacker.GetBits() == 9 + 1 + 11 + 6 );
		
		bitpacker.WriteBits( 0xFFFFFFFF, 5 );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( bitpacker.GetBits() == 32 );
		
		CHECK( buffer[0] == 0xFF );
		CHECK( buffer[1] == 0xFF );
		CHECK( buffer[2] == 0xFF );
		CHECK( buffer[3] == 0xFF );
		CHECK( buffer[4] == 0x00 );		
	}

	TEST( test_bit_packer_read_bits )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		buffer[0] = 0xFF;
		buffer[1] = 0xFF;
		buffer[2] = 0xFF;
		buffer[3] = 0xFF;
		buffer[4] = 0xFF;
		buffer[5] = 0xFF;
		buffer[6] = 0xFF;

		BitPacker bitpacker( BitPacker::Read, buffer, sizeof(buffer) );
		uint32_t value;
		bitpacker.ReadBits( value, 32 );
		CHECK( value == 0xFFFFFFFF );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( bitpacker.GetBits() == 32 );

		bitpacker.ReadBits( value, 16 );
		CHECK( value == 0x0000FFFF );
		CHECK( bitpacker.GetBytes() == 6 );
		CHECK( bitpacker.GetBits() == 32 + 16 );
		
		bitpacker.ReadBits( value, 8 );
		CHECK( value == 0x000000FF );
		CHECK( bitpacker.GetBytes() == 7 );
		CHECK( bitpacker.GetBits() == 32 + 16 + 8 );
	}

	TEST( test_bit_packer_read_bits_odd )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		buffer[0] = 0xFF;
		buffer[1] = 0xFF;
		buffer[2] = 0xFF;
		buffer[3] = 0xFF;
		buffer[4] = 0x00;

		BitPacker bitpacker( BitPacker::Read, buffer, sizeof(buffer) );

		uint32_t value;
		bitpacker.ReadBits( value, 9 );
		CHECK( bitpacker.GetBytes() == 2 );
		CHECK( bitpacker.GetBits() == 9 );
		CHECK( value == ( 1 << 9 ) - 1 );

		bitpacker.ReadBits( value, 1 );
		CHECK( bitpacker.GetBytes() == 2 );
		CHECK( bitpacker.GetBits() == 9 + 1 );
		CHECK( value == 1 );

		bitpacker.ReadBits( value, 11 );
		CHECK( bitpacker.GetBytes() == 3 );
		CHECK( bitpacker.GetBits() == 9 + 1 + 11 );
		CHECK( value == ( 1 << 11 ) - 1 );

		bitpacker.ReadBits( value, 6 );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( bitpacker.GetBits() == 9 + 1 + 11 + 6 );
		CHECK( value == ( 1 << 6 ) - 1 );

		bitpacker.ReadBits( value, 5 );
		CHECK( bitpacker.GetBytes() == 4 );
		CHECK( bitpacker.GetBits() == 32 );
		CHECK( value == ( 1 << 5 ) - 1 );
	}

	TEST( test_bit_packer_read_write_bits )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		uint32_t a = 123;
		uint32_t b = 1;
		uint32_t c = 10004;
		uint32_t d = 50234;
		uint32_t e = 1020491;
		uint32_t f = 55;
		uint32_t g = 40;
		uint32_t h = 100;
		
		const int total_bits = 256 * 8;
		const int used_bits = 7 + 1 + 14 + 16 + 20 + 6 + 6 + 7;
		const int used_bytes = 10;

		BitPacker bitpacker( BitPacker::Write, buffer, sizeof(buffer) );
		bitpacker.WriteBits( a, 7 );
		bitpacker.WriteBits( b, 1 );
		bitpacker.WriteBits( c, 14 );
		bitpacker.WriteBits( d, 16 );
		bitpacker.WriteBits( e, 20 );
		bitpacker.WriteBits( f, 6 );
		bitpacker.WriteBits( g, 6 );
		bitpacker.WriteBits( h, 7 );
		CHECK( bitpacker.GetBits() == used_bits );
		CHECK( bitpacker.GetBytes() == used_bytes );
		CHECK( bitpacker.BitsRemaining() == total_bits - used_bits );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;
		uint32_t d_out = 0xFFFFFFFF;
		uint32_t e_out = 0xFFFFFFFF;
		uint32_t f_out = 0xFFFFFFFF;
		uint32_t g_out = 0xFFFFFFFF;
		uint32_t h_out = 0xFFFFFFFF;
		
		bitpacker = BitPacker( BitPacker::Read, buffer, sizeof(buffer ) );
		bitpacker.ReadBits( a_out, 7 );
		bitpacker.ReadBits( b_out, 1 );
		bitpacker.ReadBits( c_out, 14 );
		bitpacker.ReadBits( d_out, 16 );
		bitpacker.ReadBits( e_out, 20 );
		bitpacker.ReadBits( f_out, 6 );
		bitpacker.ReadBits( g_out, 6 );
		bitpacker.ReadBits( h_out, 7 );
		CHECK( bitpacker.GetBits() == used_bits );
		CHECK( bitpacker.GetBytes() == used_bytes );
		CHECK( bitpacker.BitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_bits_required )
	{
		CHECK( Stream::BitsRequired( 0, 1 ) == 1 );
		CHECK( Stream::BitsRequired( 0, 3 ) == 2 );
		CHECK( Stream::BitsRequired( 0, 7 ) == 3 );
		CHECK( Stream::BitsRequired( 0, 15 ) == 4 );
		CHECK( Stream::BitsRequired( 0, 31 ) == 5 );
		CHECK( Stream::BitsRequired( 0, 63 ) == 6 );
		CHECK( Stream::BitsRequired( 0, 127 ) == 7 );
		CHECK( Stream::BitsRequired( 0, 255 ) == 8 );
		CHECK( Stream::BitsRequired( 0, 511 ) == 9 );
		CHECK( Stream::BitsRequired( 0, 1023 ) == 10 );
	}

	TEST( test_stream_serialize_boolean )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		bool a = false;
		bool b = true;
		bool c = false;
		bool d = false;
		bool e = true;
		bool f = false;
		bool g = true;
		bool h = true;
		
		const int total_bits = 256 * 8;
		const int used_bits = 8;
		
		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.SerializeBoolean( a ) );
		CHECK( stream.SerializeBoolean( b ) );
		CHECK( stream.SerializeBoolean( c ) );
		CHECK( stream.SerializeBoolean( d ) );
		CHECK( stream.SerializeBoolean( e ) );
		CHECK( stream.SerializeBoolean( f ) );
		CHECK( stream.SerializeBoolean( g ) );
		CHECK( stream.SerializeBoolean( h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );

		bool a_out = false;
		bool b_out = false;
		bool c_out = false;
		bool d_out = false;
		bool e_out = false;
		bool f_out = false;
		bool g_out = false;
		bool h_out = false;
		
		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.SerializeBoolean( a_out ) );
		CHECK( stream.SerializeBoolean( b_out ) );
		CHECK( stream.SerializeBoolean( c_out ) );
		CHECK( stream.SerializeBoolean( d_out ) );
		CHECK( stream.SerializeBoolean( e_out ) );
		CHECK( stream.SerializeBoolean( f_out ) );
		CHECK( stream.SerializeBoolean( g_out ) );
		CHECK( stream.SerializeBoolean( h_out ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_serialize_byte )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		uint8_t a = 123;
		uint8_t b = 1;
		uint8_t c = 10;
		uint8_t d = 50;
		uint8_t e = 2;
		uint8_t f = 68;
		uint8_t g = 190;
		uint8_t h = 210;
		
		const int total_bits = 256 * 8;
		const int used_bits = 7 + 1 + 4 + 6 + 2 + 7 + 8 + 8;
		
		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.SerializeByte( a, 0, a ) );
		CHECK( stream.SerializeByte( b, 0, b ) );
		CHECK( stream.SerializeByte( c, 0, c ) );
		CHECK( stream.SerializeByte( d, 0, d ) );
		CHECK( stream.SerializeByte( e, 0, e ) );
		CHECK( stream.SerializeByte( f, 0, f ) );
		CHECK( stream.SerializeByte( g, 0, g ) );
		CHECK( stream.SerializeByte( h, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );

		uint8_t a_out = 0xFF;
		uint8_t b_out = 0xFF;
		uint8_t c_out = 0xFF;
		uint8_t d_out = 0xFF;
		uint8_t e_out = 0xFF;
		uint8_t f_out = 0xFF;
		uint8_t g_out = 0xFF;
		uint8_t h_out = 0xFF;
		
		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.SerializeByte( a_out, 0, a ) );
		CHECK( stream.SerializeByte( b_out, 0, b ) );
		CHECK( stream.SerializeByte( c_out, 0, c ) );
		CHECK( stream.SerializeByte( d_out, 0, d ) );
		CHECK( stream.SerializeByte( e_out, 0, e ) );
		CHECK( stream.SerializeByte( f_out, 0, f ) );
		CHECK( stream.SerializeByte( g_out, 0, g ) );
		CHECK( stream.SerializeByte( h_out, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_serialize_short )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		unsigned short a = 123;
		unsigned short b = 1;
		unsigned short c = 10004;
		unsigned short d = 50234;
		unsigned short e = 2;
		unsigned short f = 55;
		unsigned short g = 40;
		unsigned short h = 100;
		
		const int total_bits = 256 * 8;
		const int used_bits = 7 + 1 + 14 + 16 + 2 + 6 + 6 + 7;
		
		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.SerializeShort( a, 0, a ) );
		CHECK( stream.SerializeShort( b, 0, b ) );
		CHECK( stream.SerializeShort( c, 0, c ) );
		CHECK( stream.SerializeShort( d, 0, d ) );
		CHECK( stream.SerializeShort( e, 0, e ) );
		CHECK( stream.SerializeShort( f, 0, f ) );
		CHECK( stream.SerializeShort( g, 0, g ) );
		CHECK( stream.SerializeShort( h, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );

		unsigned short a_out = 0xFFFF;
		unsigned short b_out = 0xFFFF;
		unsigned short c_out = 0xFFFF;
		unsigned short d_out = 0xFFFF;
		unsigned short e_out = 0xFFFF;
		unsigned short f_out = 0xFFFF;
		unsigned short g_out = 0xFFFF;
		unsigned short h_out = 0xFFFF;
		
		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.SerializeShort( a_out, 0, a ) );
		CHECK( stream.SerializeShort( b_out, 0, b ) );
		CHECK( stream.SerializeShort( c_out, 0, c ) );
		CHECK( stream.SerializeShort( d_out, 0, d ) );
		CHECK( stream.SerializeShort( e_out, 0, e ) );
		CHECK( stream.SerializeShort( f_out, 0, f ) );
		CHECK( stream.SerializeShort( g_out, 0, g ) );
		CHECK( stream.SerializeShort( h_out, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_serialize_integer )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		uint32_t a = 123;
		uint32_t b = 1;
		uint32_t c = 10004;
		uint32_t d = 50234;
		uint32_t e = 1020491;
		uint32_t f = 55;
		uint32_t g = 40;
		uint32_t h = 100;
		
		const int total_bits = 256 * 8;
		const int used_bits = 7 + 1 + 14 + 16 + 20 + 6 + 6 + 7;
		
		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.SerializeInteger( a, 0, a ) );
		CHECK( stream.SerializeInteger( b, 0, b ) );
		CHECK( stream.SerializeInteger( c, 0, c ) );
		CHECK( stream.SerializeInteger( d, 0, d ) );
		CHECK( stream.SerializeInteger( e, 0, e ) );
		CHECK( stream.SerializeInteger( f, 0, f ) );
		CHECK( stream.SerializeInteger( g, 0, g ) );
		CHECK( stream.SerializeInteger( h, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;
		uint32_t d_out = 0xFFFFFFFF;
		uint32_t e_out = 0xFFFFFFFF;
		uint32_t f_out = 0xFFFFFFFF;
		uint32_t g_out = 0xFFFFFFFF;
		uint32_t h_out = 0xFFFFFFFF;
		
		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.SerializeInteger( a_out, 0, a ) );
		CHECK( stream.SerializeInteger( b_out, 0, b ) );
		CHECK( stream.SerializeInteger( c_out, 0, c ) );
		CHECK( stream.SerializeInteger( d_out, 0, d ) );
		CHECK( stream.SerializeInteger( e_out, 0, e ) );
		CHECK( stream.SerializeInteger( f_out, 0, f ) );
		CHECK( stream.SerializeInteger( g_out, 0, g ) );
		CHECK( stream.SerializeInteger( h_out, 0, h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_serialize_float )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );
		
		float a = 12.3f;
		float b = 1.8753f;
		float c = 10004.017231f;
		float d = 50234.01231f;
		float e = 1020491.5834f;
		float f = 55.0f;
		float g = 40.9f;
		float h = 100.001f;
		
		const int total_bits = 256 * 8;
		const int used_bits = 8 * 32;
		
		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.SerializeFloat( a ) );
		CHECK( stream.SerializeFloat( b ) );
		CHECK( stream.SerializeFloat( c ) );
		CHECK( stream.SerializeFloat( d ) );
		CHECK( stream.SerializeFloat( e ) );
		CHECK( stream.SerializeFloat( f ) );
		CHECK( stream.SerializeFloat( g ) );
		CHECK( stream.SerializeFloat( h ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );

		float a_out = 0.0f;
		float b_out = 0.0f;
		float c_out = 0.0f;
		float d_out = 0.0f;
		float e_out = 0.0f;
		float f_out = 0.0f;
		float g_out = 0.0f;
		float h_out = 0.0f;
		
		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.SerializeFloat( a_out ) );
		CHECK( stream.SerializeFloat( b_out ) );
		CHECK( stream.SerializeFloat( c_out ) );
		CHECK( stream.SerializeFloat( d_out ) );
		CHECK( stream.SerializeFloat( e_out ) );
		CHECK( stream.SerializeFloat( f_out ) );
		CHECK( stream.SerializeFloat( g_out ) );
		CHECK( stream.SerializeFloat( h_out ) );
		CHECK( stream.GetBitsProcessed() == used_bits );
		CHECK( stream.GetBitsRemaining() == total_bits - used_bits );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
		CHECK( d == d_out );
		CHECK( e == e_out );
		CHECK( f == f_out );
		CHECK( g == g_out );
		CHECK( h == h_out );
	}

	TEST( test_stream_serialize_signed_byte )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );

		signed char min = -100;
		signed char max = +100;

		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		for ( signed char i = min; i <= max; ++i )
			CHECK( stream.SerializeByte( i, min, max ) );

		stream = Stream( Stream::Read, buffer, sizeof(buffer) );
		for ( signed char i = min; i <= max; ++i )
		{
			signed char value = 0;
			CHECK( stream.SerializeByte( value, min, max ) );
			CHECK( value == i );
		}
	}

	TEST( test_stream_serialize_signed_short )
	{
		uint8_t buffer[2048];
		memset( buffer, 0, sizeof( buffer ) );

		signed short min = -500;
		signed short max = +500;

		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		for ( signed short i = min; i <= max; ++i )
			CHECK( stream.SerializeShort( i, min, max ) );

		stream = Stream( Stream::Read, buffer, sizeof(buffer) );
		for ( signed short i = min; i <= max; ++i )
		{
			signed short value = 0;
			CHECK( stream.SerializeShort( value, min, max ) );
			CHECK( value == i );
		}
	}

	TEST( test_stream_serialize_signed_int )
	{
		uint8_t buffer[2048];
		memset( buffer, 0, sizeof( buffer ) );

		signed int min = -100000;
		signed int max = +100000;

		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		for ( signed int i = min; i <= max; i += 1000 )
			CHECK( stream.SerializeInteger( i, min, max ) );

		stream = Stream( Stream::Read, buffer, sizeof(buffer) );
		for ( signed int i = min; i <= max; i += 1000 )
		{
			signed int value = 0;
			CHECK( stream.SerializeInteger( value, min, max ) );
			CHECK( value == i );
		}
	}

	TEST( test_stream_check )
	{
		uint8_t buffer[256];
		memset( buffer, 0, sizeof( buffer ) );

		uint32_t a = 123;
		uint32_t b = 1;
		uint32_t c = 10004;

		Stream stream( Stream::Write, buffer, sizeof(buffer) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( a, 0, a ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( b, 0, b ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( c, 0, c ) );
		CHECK( stream.Check() );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( a_out, 0, a ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( b_out, 0, b ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( c_out, 0, c ) );
		CHECK( stream.Check() );

		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}
		
	TEST( test_stream_journal )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint32_t a = 123;
		uint32_t b = 1;
		uint32_t c = 10004;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( a, 0, a ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( b, 0, b ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( c, 0, c ) );
		CHECK( stream.Check() );

		stream.DumpJournal();

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( a_out, 0, a ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( b_out, 0, b ) );
		CHECK( stream.Check() );
		CHECK( stream.SerializeInteger( c_out, 0, c ) );
		CHECK( stream.Check() );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	bool serializeUncompressedBytes( Stream & stream, uint8_t & a, uint8_t & b, uint8_t & c )
	{
		serialize_check( stream );
		serialize_uncompressed_byte( stream, a );
		serialize_uncompressed_byte( stream, b );
		serialize_uncompressed_byte( stream, c );
		serialize_check( stream );
		return true;
	}

	bool serializeUncompressedShorts( Stream & stream, uint16_t & a, uint16_t & b, uint16_t & c )
	{
		serialize_check( stream );
		serialize_uncompressed_short( stream, a );
		serialize_uncompressed_short( stream, b );
		serialize_uncompressed_short( stream, c );
		serialize_check( stream );
		return true;
	}

	bool serializeUncompressedInts( Stream & stream, uint32_t & a, uint32_t & b, uint32_t & c )
	{
		serialize_check( stream );
		serialize_uncompressed_int( stream, a );
		serialize_uncompressed_int( stream, b );
		serialize_uncompressed_int( stream, c );
		serialize_check( stream );
		return true;
	}

	bool serializeUncompressedFloats( Stream & stream, float & a, float & b, float & c )
	{
		serialize_check( stream );
		serialize_uncompressed_float( stream, a );
		serialize_uncompressed_float( stream, b );
		serialize_uncompressed_float( stream, c );
		serialize_check( stream );
		return true;
	}

	bool serializeBools( Stream & stream, bool & a, bool & b, bool & c )
	{
		serialize_check( stream );
		serialize_bool( stream, a );
		serialize_bool( stream, b );
		serialize_bool( stream, c );
		serialize_check( stream );
		return true;
	}

	bool serializeBits( Stream & stream, uint32_t & a, uint32_t & b, uint32_t & c )
	{
		serialize_check( stream );
		serialize_bits( stream, a, 9 );
		serialize_bits( stream, b, 17 );
		serialize_bits( stream, c, 27 );
		serialize_check( stream );
		return true;
	}

	bool serializeBytes( Stream & stream, uint8_t & a, uint8_t & b, uint8_t & c )
	{
		serialize_check( stream );
		serialize_byte( stream, a, 10, 200 );
		serialize_byte( stream, b, 5, 33 );
		serialize_byte( stream, c, 30, 34 );
		serialize_check( stream );
		return true;
	}

	bool serializeShorts( Stream & stream, uint16_t & a, uint16_t & b, uint16_t & c )
	{
		serialize_check( stream );
		serialize_short( stream, a, 100, 150 );
		serialize_short( stream, b, 900, 1100 );
		serialize_short( stream, c, 1, 50000 );
		serialize_check( stream );
		return true;
	}

	bool serializeInts( Stream & stream, uint32_t & a, uint32_t & b, uint32_t & c )
	{
		serialize_check( stream );
		serialize_int( stream, a, 100, 200 );
		serialize_int( stream, b, 1000000, 2000000 );
		serialize_int( stream, c, 30000000, 34000000 );
		serialize_check( stream );
		return true;
	}

	bool serializeFloats( Stream & stream, float & a, float & b, float & c, float minimum, float maximum, float resolution )
	{
		serialize_check( stream );
		serialize_float( stream, a, minimum, maximum, resolution );
		serialize_float( stream, b, minimum, maximum, resolution );
		serialize_float( stream, c, minimum, maximum, resolution );
		serialize_check( stream );
		return true;
	}

	#ifdef NET_HAS_MATH
	bool serializeUncompressedVectors( Stream & stream, Vec4 & _a, Vec4 & _b, Vec4 & _c )
	{
		serialize_check( stream );
		net::Vector3 a,b,c;
		a.Load( _a );
		b.Load( _b );
		c.Load( _c );
		serialize_uncompressed_vector3( stream, a );
		serialize_uncompressed_vector3( stream, b );
		serialize_uncompressed_vector3( stream, c );
		serialize_check( stream );
		a.Store( _a );
		b.Store( _b );
		c.Store( _c );
		return true;
	}
	#endif

	#ifdef NET_HAS_MATH
	bool serializeUncompressedQuaternions( Stream & stream, Quat & _a, Quat & _b, Quat & _c )
	{
		serialize_check( stream );
		net::Quaternion a,b,c;
		a.Load( _a );
		b.Load( _b );
		c.Load( _c );
		serialize_uncompressed_quaternion( stream, a );
		serialize_uncompressed_quaternion( stream, b );
		serialize_uncompressed_quaternion( stream, c );
		serialize_check( stream );
		a.Store( _a );
		b.Store( _b );
		c.Store( _c );
		return true;
	}
	#endif

	#ifdef NET_HAS_MATH
	bool serializeUncompressedTransforms( Stream & stream, Mat44 & _a, Mat44 & _b, Mat44 & _c )
	{
		serialize_check( stream );
		net::Transform a,b,c;
		a.Load( _a );
		b.Load( _b );
		c.Load( _c );
		serialize_uncompressed_transform( stream, a );
		serialize_uncompressed_transform( stream, b );
		serialize_uncompressed_transform( stream, c );
		serialize_check( stream );
		a.Store( _a );
		b.Store( _b );
		c.Store( _c );
		return true;
	}
	#endif

	TEST( test_macro_serialize_uncompressed_byte )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint8_t a = 123;
		uint8_t b = 10;
		uint8_t c = 33;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedBytes( stream, a, b, c ) );

		uint8_t a_out = 0xFF;
		uint8_t b_out = 0xFF;
		uint8_t c_out = 0xFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedBytes( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_uncompressed_short )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint16_t a = 123;
		uint16_t b = 1000;
		uint16_t c = 33000;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedShorts( stream, a, b, c ) );

		uint16_t a_out = 0xFFFF;
		uint16_t b_out = 0xFFFF;
		uint16_t c_out = 0xFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedShorts( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_uncompressed_int )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint32_t a = 123;
		uint32_t b = 1000234;
		uint32_t c = 33000001;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedInts( stream, a, b, c ) );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedInts( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_uncompressed_float )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		float a = 123.6f;
		float b = 1000234.2f;
		float c = 33000001.123f;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedFloats( stream, a, b, c ) );

		float a_out = 0.0f;
		float b_out = 0.0f;
		float c_out = 0.0f;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedFloats( stream, a_out, b_out, c_out ) );
		
		const float epsilon = 0.00001f;

		CHECK_CLOSE( a, a_out, epsilon );
		CHECK_CLOSE( b, b_out, epsilon );
		CHECK_CLOSE( c, c_out, epsilon );
	}

	TEST( test_macro_serialize_bool )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		bool a = true;
		bool b = false;
		bool c = true;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeBools( stream, a, b, c ) );

		bool a_out = false;
		bool b_out = false;
		bool c_out = false;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeBools( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_bits )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint32_t a = 123;
		uint32_t b = 50023;
		uint32_t c = 502005;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeBits( stream, a, b, c ) );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeBits( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_byte )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint8_t a = 123;
		uint8_t b = 10;
		uint8_t c = 33;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeBytes( stream, a, b, c ) );

		uint8_t a_out = 0xFF;
		uint8_t b_out = 0xFF;
		uint8_t c_out = 0xFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeBytes( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_short )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint16_t a = 123;
		uint16_t b = 1000;
		uint16_t c = 33000;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeShorts( stream, a, b, c ) );

		uint16_t a_out = 0xFFFF;
		uint16_t b_out = 0xFFFF;
		uint16_t c_out = 0xFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeShorts( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_int )
	{
		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		uint32_t a = 123;
		uint32_t b = 1000234;
		uint32_t c = 33000001;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeInts( stream, a, b, c ) );

		uint32_t a_out = 0xFFFFFFFF;
		uint32_t b_out = 0xFFFFFFFF;
		uint32_t c_out = 0xFFFFFFFF;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeInts( stream, a_out, b_out, c_out ) );
		
		CHECK( a == a_out );
		CHECK( b == b_out );
		CHECK( c == c_out );
	}

	TEST( test_macro_serialize_float )
	{
		const float minimum = 0.0f;
		const float maximum = 1.0f;
		const float resolution = 0.1f;

		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		float a = 0.01f;
		float b = 0.56f;
		float c = 0.99f;

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeFloats( stream, a, b, c, minimum, maximum, resolution ) );

		float a_out = 0.0f;
		float b_out = 0.0f;
		float c_out = 0.0f;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeFloats( stream, a_out, b_out, c_out, minimum, maximum, resolution ) );
		
		CHECK_CLOSE( a, a_out, resolution );
		CHECK_CLOSE( b, b_out, resolution );
		CHECK_CLOSE( c, c_out, resolution );
	}

	#ifdef NET_HAS_MATH
	TEST( test_macro_serialize_vector )
	{
		const float minimum = 0.0f;
		const float maximum = 1.0f;
		const float resolution = 0.1f;

		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		Vec4 a( 0.01f, 0.25f, 0.12f, 0.0f );
		Vec4 b( 0.56f, 0.11f, 0.37f, 0.0f );
		Vec4 c( 0.9f, 0.05f, 0.93f, 0.0f );

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedVectors( stream, a, b, c ) );

		Vec4 a_out(0,0,0,0);
		Vec4 b_out(0,0,0,0);
		Vec4 c_out(0,0,0,0);

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedVectors( stream, a_out, b_out, c_out ) );

		CHECK( Abs( a.X() - a_out.X() ) < resolution );
		CHECK( Abs( a.Y() - a_out.Y() ) < resolution );
		CHECK( Abs( a.Z() - a_out.Z() ) < resolution );
		CHECK( a_out.W() == 1.0f );

		CHECK( Abs( b.X() - b_out.X() ) < resolution );
		CHECK( Abs( b.Y() - b_out.Y() ) < resolution );
		CHECK( Abs( b.Z() - b_out.Z() ) < resolution );
		CHECK( b_out.W() == 1.0f );

		CHECK( Abs( c.X() - c_out.X() ) < resolution );
		CHECK( Abs( c.Y() - c_out.Y() ) < resolution );
		CHECK( Abs( c.Z() - c_out.Z() ) < resolution );
		CHECK( c_out.W() == 1.0f );
	}
	#endif

	#ifdef NET_HAS_MATH
	TEST( test_macro_serialize_quaternion )
	{
		const float resolution = 0.001f;

		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		Quat a = Normalize( Quat( 0.01f, 0.25f, 0.12f, 0.0f ) );
		Quat b = Normalize( Quat( 0.56f, 0.11f, 0.37f, 0.0f ) );
		Quat c = Normalize( Quat( 0.9f, 0.05f, 0.93f, 0.0f ) );

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedQuaternions( stream, a, b, c ) );

		Quat a_out(0,0,0,0);
		Quat b_out(0,0,0,0);
		Quat c_out(0,0,0,0);

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedQuaternions( stream, a_out, b_out, c_out ) );

		CHECK( Length3( ( a - a_out ).GetVec4() ) < resolution );
		CHECK( Length3( ( b - b_out ).GetVec4() ) < resolution );
		CHECK( Length3( ( c - c_out ).GetVec4() ) < resolution );
	}
	#endif

	#ifdef NET_HAS_MATH
	TEST( test_macro_serialize_transform )
	{
		const float position_minimum = 0.0f;
		const float position_maximum = 1.0f;
		const float position_resolution = 0.1f;
		const float orientation_resolution = 0.001f;

		uint8_t buffer[256];
		uint8_t journal[256];
		memset( buffer, 0, sizeof( buffer ) );
		memset( journal, 0, sizeof( journal ) );

		Vec4 position_a( 0.01f, 0.25f, 0.12f, 0.0f );
		Vec4 position_b( 0.56f, 0.11f, 0.37f, 0.0f );
		Vec4 position_c( 0.9f, 0.05f, 0.93f, 0.0f );

		Quat orientation_a = Normalize( Quat( 0.01f, 0.25f, 0.12f, 0.0f ) );
		Quat orientation_b = Normalize( Quat( 0.56f, 0.11f, 0.37f, 0.0f ) );
		Quat orientation_c = Normalize( Quat( 0.9f, 0.05f, 0.93f, 0.0f ) );

		Mat44 transform_a = BuildTransform( orientation_a, position_a );
		Mat44 transform_b = BuildTransform( orientation_b, position_b );
		Mat44 transform_c = BuildTransform( orientation_c, position_c );

		Stream stream( Stream::Write, buffer, sizeof(buffer), journal, sizeof(journal) );
		CHECK( serializeUncompressedTransforms( stream, transform_a, transform_b, transform_c ) );

		Mat44 transform_a_out;
		Mat44 transform_b_out;
		Mat44 transform_c_out;

		stream = Stream( Stream::Read, buffer, sizeof(buffer ), journal, sizeof(journal) );
		CHECK( serializeUncompressedTransforms( stream, transform_a_out, transform_b_out, transform_c_out ) );

		Vec4 position_a_out = transform_a_out.GetRow(3);
		Vec4 position_b_out = transform_b_out.GetRow(3);
		Vec4 position_c_out = transform_c_out.GetRow(3);

		Quat orientation_a_out( transform_a_out );
		Quat orientation_b_out( transform_b_out );
		Quat orientation_c_out( transform_c_out );

		CHECK( Abs( position_a.X() - position_a_out.X() ) < position_resolution );
		CHECK( Abs( position_a.Y() - position_a_out.Y() ) < position_resolution );
		CHECK( Abs( position_a.Z() - position_a_out.Z() ) < position_resolution );
		CHECK( position_a_out.W() == 1.0f );

		CHECK( Abs( position_b.X() - position_b_out.X() ) < position_resolution );
		CHECK( Abs( position_b.Y() - position_b_out.Y() ) < position_resolution );
		CHECK( Abs( position_b.Z() - position_b_out.Z() ) < position_resolution );
		CHECK( position_b_out.W() == 1.0f );

		CHECK( Abs( position_c.X() - position_c_out.X() ) < position_resolution );
		CHECK( Abs( position_c.Y() - position_c_out.Y() ) < position_resolution );
		CHECK( Abs( position_c.Z() - position_c_out.Z() ) < position_resolution );
		CHECK( position_c_out.W() == 1.0f );

		CHECK( Length3( ( orientation_a - orientation_a_out ).GetVec4() ) < orientation_resolution );
		CHECK( Length3( ( orientation_b - orientation_b_out ).GetVec4() ) < orientation_resolution );
		CHECK( Length3( ( orientation_c - orientation_c_out ).GetVec4() ) < orientation_resolution );
	}
	#endif
}
