/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netStream.h"
#include "network/netEvents.h"

using namespace net;

SUITE( NetEvents )
{
	enum EventTypes
	{
		EVENT_A,
		EVENT_B,
		EVENT_NumTypes
	};
	
	class EventA : public Event
	{
	public:
		
		int i,j,k;

		EventA() : Event( EVENT_A )
		{
			i = j = k = 0;
		}
	
		bool Serialize( Stream & stream, void * context )
		{
			serialize_uncompressed_int( stream, i );
			serialize_uncompressed_int( stream, j );
			serialize_uncompressed_int( stream, k );
			return true;
		}
		
		bool operator == ( const EventA & other ) const
		{
			return i == other.i && j == other.j && k == other.k;
		}
		
		bool operator != ( const EventA & other ) const
		{
			return ! ( *this == other );
		}
		
		void Trace( const char channel[] )
		{
			NET_DEBUG( channel, "event A: i=%d, j=%d, k=%d", i, j, k );
		}

		void Print()
		{
			printf( "event A: i=%d, j=%d, k=%d", i, j, k );
		}
	};
	
	class EventB : public Event
	{
	public:

		bool i,j,k;
		float x,y,z;
		
		EventB() : Event( EVENT_B )
		{
			i = j = k = false;
			x = y = z = 0.0f;
		}

		bool Serialize( Stream & stream, void * context )
		{
			serialize_bool( stream, i );
			serialize_bool( stream, j );
			serialize_bool( stream, k );
			serialize_uncompressed_float( stream, x );
			serialize_uncompressed_float( stream, y );
			serialize_uncompressed_float( stream, z );
			return true;
		}

		bool operator == ( const EventB & other ) const
		{
			return i == other.i && j == other.j && k == other.k &&
				   x == other.x && y == other.y && z == other.z;
		}

		bool operator != ( const EventB & other ) const
		{
			return ! ( *this == other );
		}
		
		void Trace( const char channel[] )
		{
			NET_DEBUG( channel, "event B: i=%d, j=%d, k=%d, x=%1f, y=%1f, z=%1f", i, j, k, x, y, z );
		}
		
		void Print()
		{
			printf( "event B: i=%d, j=%d, k=%d, x=%1f, y=%1f, z=%1f\n", i, j, k, x, y, z );
		}
	};
	
	class TestEventFactory : public AtomFactory
	{
	public:
		

		int GetNumTypes() const
		{
			return EVENT_NumTypes;
		}
		
		const char * GetTypeName( int type ) const
		{
			if ( type == EVENT_A )
				return "a";
			else if ( type == EVENT_B )
				return "b";
			else
				return "???";
		}

        void Construct( int type, void * block )
        {
			if ( type == EVENT_A )
			{
				NET_ASSERT( sizeof( EventA ) <= (size_t) GetConfig().maxAtomSize );
				new(block) EventA();
			}
			else if ( type == EVENT_B )
			{
				NET_ASSERT( sizeof( EventB ) <= (size_t) GetConfig().maxAtomSize );
				new(block) EventB();
			}
        }
	};
	
	TEST( test_event_send )
	{
		// test send

		TestEventFactory eventFactory;
		
		CHECK( eventFactory.GetNumTypes() == EVENT_NumTypes );
		
		EventQueue eventQueue( eventFactory );

		EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
		EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
		
		CHECK( a );
		CHECK( b );
		
		a->i = 0;
		a->j = 1;
		a->k = 2;
		
		b->i = true;
		b->j = false;
		b->k = true;
		b->x = 100;
		b->y = 10;
		b->z = 86;
		
		CHECK( eventQueue.GetEventsSent() == 0 );

		eventQueue.Send( a );
		eventQueue.Send( b );

		CHECK( eventQueue.GetEventsSent() == 2 );

        // make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}
	
	TEST( test_event_acks )
	{
		// test send

		TestEventFactory eventFactory;
		
		CHECK( eventFactory.GetNumTypes() == EVENT_NumTypes );
		
		EventQueue eventQueue( eventFactory );

		EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
		EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
		
		CHECK( a );
		CHECK( b );
		
		a->i = 0;
		a->j = 1;
		a->k = 2;
		
		b->i = true;
		b->j = false;
		b->k = true;
		b->x = 100;
		b->y = 10;
		b->z = 86;
		
		CHECK( eventQueue.GetEventsSent() == 0 );

		eventQueue.Send( a );
		eventQueue.Send( b );

		CHECK( eventQueue.GetEventsSent() == 2 );

        // make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}

	TEST( test_event_receive )
	{
        EventQueueConfig eventQueueConfig;

		const float DeltaTime = eventQueueConfig.resendTime;
		const int PacketSize = 1024;
		const int JournalSize = 1024;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		// queue events to send

		TestEventFactory eventFactory;
		
		CHECK( eventFactory.GetNumTypes() == EVENT_NumTypes );
		
		EventQueue eventQueue( eventFactory );

		EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
		EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
		
		CHECK( a );
		CHECK( b );
		
		a->i = 0;
		a->j = 1;
		a->k = 2;
		
		b->i = true;
		b->j = false;
		b->k = true;
		b->x = 100;
		b->y = 10;
		b->z = 86;
		
		EventA original_a = *a;
		EventB original_b = *b;
		
		CHECK( eventQueue.GetEventsSent() == 0 );

		eventQueue.Send( a );
		eventQueue.Send( b );

		CHECK( eventQueue.GetEventsSent() == 2 );

		// actually send the events via serialize to packet

		const int NumPackets = 10;

		struct Packet
		{
			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
		};

		Packet packets[NumPackets];

		for ( int i = 0; i < NumPackets; ++i )
		{
			eventQueue.Update( timeBase );

			Stream stream( Stream::Write, packets[i].data, PacketSize, packets[i].journal, JournalSize );
			bool result = eventQueue.SerializePacket( stream, (uint16_t) i );
			CHECK( result );
			if ( result )
				eventQueue.CommitPacket();
			else
				eventQueue.DiscardPacket();
			CHECK( eventQueue.GetEventsSent() == 2 );
			int eventsWritten = eventQueue.GetEventsWritten();
			CHECK( eventsWritten == ( i + 1 ) * 2 );

            timeBase.time += timeBase.deltaTime;
		}

		// receive packets

		for ( int i = 0; i < NumPackets; ++i )
		{																	  
			Stream stream( Stream::Read, packets[i].data, PacketSize, packets[i].journal, JournalSize );
			bool result = eventQueue.SerializePacket( stream, (uint16_t) i );
			CHECK( result );
			CHECK( eventQueue.GetEventsReceived() == 0 );
			int eventsRead = eventQueue.GetEventsRead();
			CHECK( eventsRead == ( i + 1 ) * 2 );
		}
		
		// process acks
		
		for ( int i = 0; i < NumPackets; ++i )
			eventQueue.ProcessAck( i );

		// receive events

		int loopCount = 0;
		while ( Event * event = eventQueue.Receive() )
		{
			if ( loopCount == 0 )
			{
				CHECK( event->GetType() == EVENT_A );
				EventA * a = (EventA*) event;
				CHECK( *a == original_a );
			}
			else if ( loopCount == 1 )
			{
				CHECK( event->GetType() == EVENT_B );
				EventB * b = (EventB*) event;
				CHECK( *b == original_b );
			}
			loopCount++;
			eventFactory.Destroy( event );
		}

		CHECK( loopCount == 2 );
		CHECK( eventQueue.GetEventsReceived() == 2 );
		
		// make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}
	
	TEST( test_event_send_receive )
	{
		const int NumEvents = 256;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestEventFactory eventFactory;

		Event * sendEvents[NumEvents];
		for ( int i = 0; i < NumEvents; ++i )
		{
			if ( rand() % 2 )
			{
				EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
				NET_ASSERT( a );
				a->i = rand() % 1000;
				a->j = rand() % 1000;
				a->k = rand() % 1000;
				sendEvents[i] = a;
			}
			else
			{
				EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
				NET_ASSERT( b );
				b->i = ( rand() % 2 ) ? true : false;
				b->j = ( rand() % 2 ) ? true : false;
				b->k = ( rand() % 2 ) ? true : false;
				b->x = float( rand() % 1000 );
				b->y = float( rand() % 1000 );
				b->z = float( rand() % 1000 );
				sendEvents[i] = b;
			}
		}

		EventQueue eventQueue( eventFactory );
		
		int eventsSent = 0;
		int eventsReceived = 0;
		unsigned int sequence = 1;

		while ( eventsReceived < NumEvents )
		{
			while ( eventQueue.CanSend() && eventsSent < NumEvents )
			{
				Event * clonedEvent = (Event*) eventFactory.Clone( sendEvents[eventsSent] );
				CHECK( clonedEvent );
				CHECK( eventQueue.Send( clonedEvent ) );
				eventsSent++;
			}

			uint8_t data[PacketSize];
 			uint8_t journal[JournalSize];

			{
				Stream stream( Stream::Write, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
				if ( result )
					eventQueue.CommitPacket();
				else
					eventQueue.DiscardPacket();
			}

			{
				Stream stream( Stream::Read, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
			}

			eventQueue.Update( timeBase );

			eventQueue.ProcessAck( sequence );

			while ( Event * event = eventQueue.Receive() )
			{
				CHECK( sendEvents[eventsReceived]->GetType() == event->GetType() );
				if ( event->GetType() == EVENT_A )
				{
					EventA * a_sent = static_cast<EventA*>( sendEvents[eventsReceived] );
					EventA * a_recv = static_cast<EventA*>( event );
					CHECK( *a_sent == *a_recv );
					if ( *a_sent != *a_recv )
					{
						static_cast<EventA*>(event)->Print();
						a_sent->Print();
						printf( "error: invalid event a\n" );
						exit(1);
					}
				}
				else
				{
					EventB * b_sent = static_cast<EventB*>( sendEvents[eventsReceived] );
					EventB * b_recv = static_cast<EventB*>( event );
					CHECK( *b_sent == *b_recv );
					if ( *b_sent != *b_recv )
					{
						static_cast<EventB*>(event)->Print();
						b_sent->Print();
						printf( "error: invalid event b\n" );
						exit(1);
					}
				}
				eventFactory.Destroy( event );
				eventsReceived++;
			}

			sequence++;

            timeBase.time += timeBase.deltaTime;
		}

		for ( int i = 0; i < NumEvents; ++i )
			eventFactory.Destroy( sendEvents[i] );

		// make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}

	TEST( test_event_send_receive_with_latency )
	{
		const int NumEvents = 256;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestEventFactory eventFactory;

		struct EventData
		{
			Event * event;
			int eventType;
			EventA a_copy;			// hack: need copy because the sent event is deleted on ack
			EventB b_copy;
		};
		
		EventData eventData[NumEvents];
		for ( int i = 0; i < NumEvents; ++i )
		{
			if ( rand() % 2 )
			{
				EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
				NET_ASSERT( a );
				a->i = rand() % 1000;
				a->j = rand() % 1000;
				a->k = rand() % 1000;
				eventData[i].event = a;
				eventData[i].eventType = EVENT_A;
				eventData[i].a_copy = *a;
			}
			else
			{
				EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
				NET_ASSERT( b );
				b->i = ( rand() % 2 ) ? true : false;
				b->j = ( rand() % 2 ) ? true : false;
				b->k = ( rand() % 2 ) ? true : false;
				b->x = float( rand() % 1000 );
				b->y = float( rand() % 1000 );
				b->z = float( rand() % 1000 );
				eventData[i].event = b;
				eventData[i].eventType = EVENT_B;
				eventData[i].b_copy = *b;
			}
		}

		EventQueue eventQueue( eventFactory );
		
		int eventsSent = 0;
		int eventsReceived = 0;
		unsigned int sequence = 1;

		while ( eventsReceived < NumEvents )
		{
			while ( eventQueue.CanSend() && eventsSent < NumEvents )
			{
				CHECK( eventQueue.Send( eventData[eventsSent].event ) );
				eventsSent++;
			}

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];

			{
				Stream stream( Stream::Write, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
				if ( result )
					eventQueue.CommitPacket();
				else
					eventQueue.DiscardPacket();
			}

			{
				Stream stream( Stream::Read, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
			}

			eventQueue.Update( timeBase );

 			int ack = sequence - 30;
			if ( ack >= 1 )
				eventQueue.ProcessAck( sequence );

			while ( Event * event = eventQueue.Receive() )
			{
				CHECK( eventData[eventsReceived].eventType == event->GetType() );
				if ( event->GetType() == EVENT_A )
				{
					EventA * a = static_cast<EventA*>( event );
					CHECK( *a == eventData[eventsReceived].a_copy );
					if ( *a != eventData[eventsReceived].a_copy )
					{
						static_cast<EventA*>(event)->Print();
						eventData[eventsReceived].a_copy.Print();
						printf( "error: invalid event a\n" );
						exit(1);
					}
				}
				else
				{
					EventB * b = static_cast<EventB*>( event );
					CHECK( *b == eventData[eventsReceived].b_copy );
					if ( *b != eventData[eventsReceived].b_copy )
					{
						static_cast<EventB*>(event)->Print();
						eventData[eventsReceived].b_copy.Print();
						printf( "error: invalid event b\n" );
						exit(1);
					}
				}
				eventFactory.Destroy( event );
				eventsReceived++;
			}

			sequence++;

            timeBase.time += timeBase.deltaTime;
		}
		
		// make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}

	TEST( test_event_send_receive_with_latency_and_packet_loss )
	{
		const int NumEvents = 256;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestEventFactory eventFactory;

		struct EventData
		{
			Event * event;
			int eventType;
			EventA a_copy;			// hack: need copy because the sent event is deleted on ack
			EventB b_copy;
		};
		
		EventData eventData[NumEvents];
		for ( int i = 0; i < NumEvents; ++i )
		{
			if ( rand() % 2 )
			{
				EventA * a = static_cast<EventA*>( eventFactory.Create( EVENT_A ) );
				NET_ASSERT( a );
				a->i = rand() % 1000;
				a->j = rand() % 1000;
				a->k = rand() % 1000;
				eventData[i].event = a;
				eventData[i].eventType = EVENT_A;
				eventData[i].a_copy = *a;
			}
			else
			{
				EventB * b = static_cast<EventB*>( eventFactory.Create( EVENT_B ) );
				NET_ASSERT( b );
				b->i = ( rand() % 2 ) ? true : false;
				b->j = ( rand() % 2 ) ? true : false;
				b->k = ( rand() % 2 ) ? true : false;
				b->x = float( rand() % 1000 );
				b->y = float( rand() % 1000 );
				b->z = float( rand() % 1000 );
				eventData[i].event = b;
				eventData[i].eventType = EVENT_B;
				eventData[i].b_copy = *b;
			}
		}

		EventQueue eventQueue( eventFactory );
		
		int eventsSent = 0;
		int eventsReceived = 0;
		unsigned int sequence = 1;

		while ( eventsReceived < NumEvents )
		{
			while ( eventQueue.CanSend() && eventsSent < NumEvents )
			{
				CHECK( eventQueue.Send( eventData[eventsSent].event ) );
				eventsSent++;
			}

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];

			bool dropPacket = ( rand() % 2 ) != 0;
			{
				Stream stream( Stream::Write, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
			}
			
			if ( !dropPacket )
			{
				eventQueue.CommitPacket();
				Stream stream( Stream::Read, data, PacketSize, journal, JournalSize );
				bool result = eventQueue.SerializePacket( stream, (uint16_t) sequence );
				CHECK( result );
			}
			else
			{
				eventQueue.DiscardPacket();
			}

			eventQueue.Update( timeBase );

 			int ack = sequence - 30;
			if ( ack >= 1 )
				eventQueue.ProcessAck( sequence );

			while ( Event * event = eventQueue.Receive() )
			{
				CHECK( eventData[eventsReceived].eventType == event->GetType() );
				if ( event->GetType() == EVENT_A )
				{
					EventA * a = static_cast<EventA*>( event );
					CHECK( *a == eventData[eventsReceived].a_copy );
					if ( *a != eventData[eventsReceived].a_copy )
					{
						static_cast<EventA*>(event)->Print();
						eventData[eventsReceived].a_copy.Print();
						printf( "error: invalid event a\n" );
						exit(1);
					}
				}
				else
				{
					EventB * b = static_cast<EventB*>( event );
					CHECK( *b == eventData[eventsReceived].b_copy );
					if ( *b != eventData[eventsReceived].b_copy )
					{
						static_cast<EventB*>(event)->Print();
						eventData[eventsReceived].b_copy.Print();
						printf( "error: invalid event b\n" );
						exit(1);
					}
				}
				eventFactory.Destroy( event );
				eventsReceived++;
			}

			sequence++;

            timeBase.time += timeBase.deltaTime;
		}
		
		// make sure the event queue is cleaned up before factory dtor
		
		eventQueue.Reset();
	}
}
