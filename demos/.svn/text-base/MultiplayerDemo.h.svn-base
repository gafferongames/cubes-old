/*
	Networked Physics Demo
	Copyright Â© 2008-2011 Glenn Fiedler
	http://www.gafferongames.com/networking-for-game-programmers
*/

#include "demos/Demo.h"
#include "engine/Hypercube.h"
#include "network/netTransportLAN.h"
#include "network/netProtocolManagers.h"
#include "network/netDataTypes.h"

//#define DISABLE_NETWORKING
//#define DISABLE_PUSH_PULL
//#define DISABLE_INACTIVE_PUSH
//#define DISABLE_CORRECTIONS
//#define DISABLE_CONFIRMATION
#define DISABLE_SESSION_ID

//#define DEBUG_PACKET_LOSS
//#define DEBUG_CORRECTIONS
//#define DEBUG_NOT_AT_REST
//#define DEBUG_UNCONFIRMED
//#define DEBUG_CONFIRMATION
//#define DEBUG_SEND_PACKET_BYTES
//#define DEBUG_RECV_PACKET_BYTES
//#define DEBUG_CUBE_BYTES
//#define DEBUG_SIZEOF_STATE
//#define DEBUG_JOURNAL
//#define DEBUG_SERVER
//#define DEBUG_ACTIVATION
//#define DEBUG_PUSH_PULL
//#define DEBUG_READ_WRITE
//#define DEBUG_SESSION

const int MaxNodes = MaxPlayers + 1;			// IMPORTANT: node 0 = dedicated server, node 1 = player 0, etc...
#ifdef DEBUG_JOURNAL
const int MaxDataBytes = 500;
const int MaxJournalBytes = 500;
const int MaxPacketBytes = 1024;
#else
const int MaxDataBytes = 256;
#endif
const int MaxStateBytes = 128;
const int MaxStateHeaders = 256;
const int MaxStateHeaderBytes = 32;
#ifndef DEBUG_PUSH_PULL
const int MaxObjectsPerPacket = 64;
#else
const int MaxObjectsPerPacket = 8;
#endif
const int MaxCorrectionsPerPacket = 8;

const int MaxPacketInfos = 64;
const int MaxConfirmInfos = 1024;
const int SessionIdBits = 5;

const int SendRate = 2;							// 1 = 60pps, 2 = 30pps, 3 = 20pps etc...

const float ActivationDistance = 5.0f;
const float CorrectionDistance = 0.25f;
const uint32_t CorrectionResendFrames = 20;

const int Resolution = 1024;
const int SmallLinearVelocity = 4 * Resolution;
const int MaxLinearVelocity = 100 * Resolution;
const int SmallAngularVelocity = 4 * Resolution;
const int MaxCubeAngularVelocity = 25 * Resolution;
const int MaxPlayerAngularVelocity = 100 * Resolution;
const int RelativePositionBound = 10 * Resolution;
const int PositionBoundXY = 1024 * Resolution;
const int PositionSmallZ = 4 * Resolution;
const int PositionBoundZ = 100 * Resolution;

#ifndef DISABLE_NETWORKING

enum ProtocolManagers
{
	PROTOCOL_Reliability,
	#ifndef DISABLE_CORRECTIONS
	PROTOCOL_Correction,
	#endif
	PROTOCOL_State,
	PROTOCOL_NumProtocols
};

enum StateTypes
{
	STATE_Cube,				// state for a cube in the world
	STATE_Player,			// state for player cube (input + cubes state)
	STATE_NumTypes
};

class StateHeader : public net::StateHeader
{
public:
	
	int origin_x;
	int origin_y;
	
	StateHeader()
	{
		origin_x = 0;
		origin_y = 0;
	}
	
	bool Serialize( net::Stream & stream )
	{
		serialize_int( stream, origin_x, -PositionBoundXY, +PositionBoundXY );
		serialize_int( stream, origin_y, -PositionBoundXY, +PositionBoundXY );
		return true;
	}
};

struct Stats
{
	float minCubeBits;
	float maxCubeBits;
	float avgCubeBits;
	
	float minSendPacketBytes;
	float maxSendPacketBytes;
	float avgSendPacketBytes;

	float minRecvPacketBytes;
	float maxRecvPacketBytes;
	float avgRecvPacketBytes;
	
	Stats()
	{
		minCubeBits = 1000.0f * 8.0f;
		maxCubeBits = 0.0f;
 		avgCubeBits = 0.0f;

		minSendPacketBytes = 10000.0f;
		maxSendPacketBytes = 0.0f;
		avgSendPacketBytes = 0.0f;

		minRecvPacketBytes = 10000.0f;
		maxRecvPacketBytes = 0.0f;
		avgRecvPacketBytes = 0.0f;
	}
};

static Stats stats;

class CubeState : public net::State
{
public:
	
	uint32_t orientation;
	int32_t position_x;
	int32_t position_y;
	int32_t position_z;
	int32_t linear_velocity_x;
	int32_t linear_velocity_y;
	int32_t linear_velocity_z;
	int32_t angular_velocity_x;
	int32_t angular_velocity_y;
	int32_t angular_velocity_z;
	uint32_t id : 20;
	uint32_t enabled : 1;
	uint32_t authority : 3;
	#ifndef DISABLE_SESSION_ID
	uint32_t session : SessionIdBits;
	#endif

	CubeState( int _type ) : net::State( _type )
	{
		// ...
	}

	CubeState() : net::State( STATE_Cube )
	{
		// ...
	}
		
	bool Serialize( net::Stream & stream, void * context )
	{
	    int start_bits = stream.GetBitsProcessed();
	
		StateHeader * header = (StateHeader*) context;
		NET_ASSERT( header );
	
		serialize_bitfield( stream, this->id, 1, (1<<20) - 1 );
		serialize_bitfield( stream, enabled, 0, 1 );
		serialize_bitfield( stream, authority, 0, MaxPlayers );
		
		#ifndef DISABLE_SESSION_ID
		serialize_bitfield( stream, session, 0, (1<<SessionIdBits) - 1 );
		#endif

		int32_t offset_x, offset_y;
		if ( stream.IsWriting() )
		{
			offset_x = position_x - header->origin_x;
			offset_y = position_y - header->origin_y;
		}

		serialize_int( stream, offset_x, -RelativePositionBound, +RelativePositionBound );
		serialize_int( stream, offset_y, -RelativePositionBound, +RelativePositionBound );
		if ( stream.IsReading() )
		{
			position_x = header->origin_x + offset_x;
			position_y = header->origin_y + offset_y;
		}

		bool small_z = position_z < PositionSmallZ;
		serialize_bool( stream, small_z );
		if ( small_z )
			serialize_int( stream, position_z, 0, PositionSmallZ );
		else
			serialize_int( stream, position_z, PositionSmallZ, PositionBoundZ );

		serialize_bits( stream, orientation, 32 );

		if ( enabled )
		{
			bool small_linear_velocity = false;
			
			if ( stream.IsWriting() )
			{
				small_linear_velocity = math::abs( linear_velocity_x ) < SmallLinearVelocity &&
								        math::abs( linear_velocity_y ) < SmallLinearVelocity &&
								        math::abs( linear_velocity_z ) < SmallLinearVelocity;
			}
		
			serialize_bool( stream, small_linear_velocity );
			
			if ( small_linear_velocity )
			{
				serialize_int( stream, linear_velocity_x, -SmallLinearVelocity, +SmallLinearVelocity );
				serialize_int( stream, linear_velocity_y, -SmallLinearVelocity, +SmallLinearVelocity );
				serialize_int( stream, linear_velocity_z, -SmallLinearVelocity, +SmallLinearVelocity );
			}
			else
			{
				serialize_int( stream, linear_velocity_x, -MaxLinearVelocity, +MaxLinearVelocity );
				serialize_int( stream, linear_velocity_y, -MaxLinearVelocity, +MaxLinearVelocity );
				serialize_int( stream, linear_velocity_z, -MaxLinearVelocity, +MaxLinearVelocity );
			}
			
			bool small_angular_velocity = false;
			
			if ( stream.IsWriting() )
			{
				small_angular_velocity = math::abs( angular_velocity_x ) < SmallAngularVelocity &&
								         math::abs( angular_velocity_y ) < SmallAngularVelocity &&
								         math::abs( angular_velocity_z ) < SmallAngularVelocity;
			}
		
			serialize_bool( stream, small_angular_velocity );

			if ( small_angular_velocity )
			{
				serialize_int( stream, angular_velocity_x, -SmallAngularVelocity, +SmallAngularVelocity );
				serialize_int( stream, angular_velocity_y, -SmallAngularVelocity, +SmallAngularVelocity );
				serialize_int( stream, angular_velocity_z, -SmallAngularVelocity, +SmallAngularVelocity );
			}
			else
			{
				if ( id <= MaxPlayers )
				{
					serialize_int( stream, angular_velocity_x, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
					serialize_int( stream, angular_velocity_y, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
					serialize_int( stream, angular_velocity_z, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
				}
				else
				{
					serialize_int( stream, angular_velocity_x, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
					serialize_int( stream, angular_velocity_y, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
					serialize_int( stream, angular_velocity_z, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
				}
			}
		}
		
	    int finish_bits = stream.GetBitsProcessed();
		
		if ( id > MaxPlayers )
		{
			const int cube_bits = finish_bits - start_bits;
			if ( cube_bits < stats.minCubeBits )
				stats.minCubeBits = cube_bits;
			if ( cube_bits > stats.maxCubeBits )
				stats.maxCubeBits = cube_bits;
			stats.avgCubeBits += ( cube_bits - stats.avgCubeBits ) * 0.05f;
		}
		
		return true;
	}
	
    void Trace( const char channel[] )
    {
		NET_TRACE( channel, "cube state" );
    }
};

class PlayerState : public CubeState
{
public:

	uint32_t frame;
	game::Input input;
	
	PlayerState() : CubeState( STATE_Player )
	{
		// ...
	}
	
	bool Serialize( net::Stream & stream, void * context )
	{
		serialize_uncompressed_int( stream, frame );
		if ( !input.Serialize( stream ) )
			return false;
		return CubeState::Serialize( stream, context );
	}

	void Trace( const char channel[] )
	{
		NET_TRACE( channel, "player state" );
	}
};

class StateFactory : public net::StateFactory
{
public:
	
	StateFactory( const net::AtomFactoryConfig & config ) : net::StateFactory( config ) 
	{
		m_headerPool = new net::PoolAllocator( MaxStateHeaders, MaxStateHeaderBytes );
	}
	
	~StateFactory()
	{
		delete m_headerPool;
		m_headerPool = NULL;
	}
	
	int GetNumTypes() const
	{
		return STATE_NumTypes;
	}
	
	const char * GetTypeName( int type ) const
	{
		if ( type == STATE_Cube )
			return "cube";
		else if ( type == STATE_Player )
			return "player";
		else
			return "???";
	}

    void Construct( int type, void * block )
    {
		if ( type == STATE_Cube )
		{
			NET_ASSERT( sizeof( CubeState ) <= (size_t) GetConfig().maxAtomSize );
			new(block) CubeState();
		}
		else if ( type == STATE_Player )
		{
			NET_ASSERT( sizeof( PlayerState ) <= (size_t) GetConfig().maxAtomSize );
			new(block) PlayerState();
		}
    }

	net::StateHeader * CreateStateHeader()
	{
		uint8_t * block = (uint8_t*) m_headerPool->Allocate();
		NET_ASSERT( block );
		new(block) StateHeader();
		return (net::StateHeader*) block;
	}

	void DestroyStateHeader( net::StateHeader * header )
	{
		NET_ASSERT( header );
		header->~StateHeader();
		m_headerPool->Free( header );
	}
	
private:
	
	net::PoolAllocator * m_headerPool;
};

class ReliabilityManager : public net::ReliabilityManager
{
public:
	
	// ...	
};

#ifndef DISABLE_CORRECTIONS

struct Correction
{
 	ObjectId id;
 	uint32_t framesSinceLastSent;		 	// frames since this correction was last sent
	uint32_t counter : 16;					// counter increases each time a new correction is queued while an entry for that object id is unacked. correction is only acked if counter is packet acked matches entry.
	uint32_t acked : 1;						// true if this correction has been acked (will be removed from send queue next update)
 	int position_x;
	int position_y;
	int position_z;
	uint32_t orientation;
	
	bool Serialize( net::Stream & stream )
	{
		serialize_int( stream, this->id, 1, (1<<20) - 1 );
		serialize_int( stream, position_x, -PositionBoundXY, +PositionBoundXY );
		serialize_int( stream, position_y, -PositionBoundXY, +PositionBoundXY );
		serialize_int( stream, position_z, 0, +PositionBoundZ );
		serialize_bits( stream, orientation, 32 );
		return true;
	}
};

struct CorrectionInfo
{
 	ObjectId id;							// id of correction so that we can find it in send queue
	uint16_t counter;						// counter of correction at time of send (so we can identify if ack is for particular correction)
};

struct CorrectionPacketInfo
{
	CorrectionPacketInfo()
	{
		sequence = 0;
		valid = 0;
		numCorrections = 0;
	}
	
 	uint32_t sequence : 16;							// sequence # this info applies to
	uint32_t valid : 1;								// 1 if this packet info is valid
	uint32_t numCorrections : 15;					// number of corrections updates included in this packet
	CorrectionInfo corrections[MaxCorrectionsPerPacket];
};

class CorrectionManager : public net::ProtocolManager
{
public:
	
	CorrectionManager()
	{
		sendQueueIndex = 0;
	}
	
	void AddCorrection( ObjectId objectId, const math::Vector & position, const math::Quaternion & orientation )
	{
		NET_ASSERT( objectId != 0 );
		
		// setup correction to be added
		Correction correction;
		correction.id = objectId;
		correction.position_x = (int) math::floor( position.x * Resolution + 0.5f );
		correction.position_y = (int) math::floor( position.y * Resolution + 0.5f );
		correction.position_z = (int) math::floor( position.z * Resolution + 0.5f );
		CompressOrientation( orientation, correction.orientation );
		correction.framesSinceLastSent = CorrectionResendFrames;
		correction.counter = 1;
		correction.acked = 0;

		// look for any existing corrections matching the object id
		std::vector<Correction> & sendQueue = GetSendQueue();
		for ( int i = 0; i < (int) sendQueue.size(); ++i )
		{
			Correction & existing = sendQueue[i];
			if ( !existing.acked && existing.id == correction.id )
			{
				// if existing correction is totally identical, there is no need to add a new one
				if ( existing.position_x == correction.position_x && 
			         existing.position_y == correction.position_y &&
			         existing.position_z == correction.position_z &&
			         existing.orientation == correction.orientation )
				{
					#ifdef DEBUG_CORRECTIONS
					printf( "ignore identical correction %d\n", objectId );
					#endif		
					return;
				}
				// if the existing correction is different, mark this one as acked (outdated)
				// and add the new correction at the end, with a counter one greater than this correction
				// this ensures that acks for the existing correction do not apply to our new correction
				existing.acked = 1;
				correction.counter = existing.counter + 1;
				#ifdef DEBUG_CORRECTIONS
				printf( "update correction %d [%d]\n", objectId, correction.counter );
				#endif
				break;
			}
		}
		
		#ifdef DEBUG_CORRECTIONS
		printf( "add correction %d [%d]\n", objectId, correction.counter );
		#endif		
		
		sendQueue.push_back( correction );
	}
		
	std::vector<Correction> & GetReceivedCorrections()
	{
		return receivedCorrections;
	}
	
	void ClearReceivedCorrections()
	{
		receivedCorrections.clear();
	}
		
protected:
		
	const char * GetName() const
	{
		return "correction manager";
	}
				
	void Reset()
	{
		sendQueueIndex = 0;
		sendQueue[0].clear();
		sendQueue[1].clear();
		receivedCorrections.clear();
	}
	
	void Update( const net::TimeBase & timeBase )
	{
		// pass over send queue and update frame accumulator for corrections
		// frame accumulator is used to delay resending corrections until min time has passed
		std::vector<Correction> & sendQueue = GetSendQueue();
		for ( int i = 0; i < (int) sendQueue.size(); ++i )
			sendQueue[i].framesSinceLastSent++;
	}
	
	bool Serialize( class net::Stream & stream, net::ProtocolInfo ** info )
	{
		// serialize # of corrections
		int numCorrections = 0;
		if ( stream.IsWriting() )
		{
			numCorrections = packetData.size();
			NET_ASSERT( numCorrections <= MaxCorrectionsPerPacket );
		}
		serialize_int( stream, numCorrections, 0, MaxCorrectionsPerPacket );
		if ( stream.IsReading() )
			packetData.resize( numCorrections );
					
		// serialize corrections (assumes we always have room to write them all)
		for ( int i = 0; i < numCorrections; ++i )
		{
			if ( !packetData[i].Serialize( stream ) )
				return false;
		}
		
		return true;
	}
			
	void BeforeRead( const net::TimeBase & timeBase, net::ProtocolInfo ** info, int packetBytes )
	{
		packetData.clear();
	}
	
	void AfterRead( const net::TimeBase & timeBase, net::ProtocolInfo ** info, int packetBytes, bool commit )
	{
		if ( commit )
		{
			// add to received corrections
			for ( int i = 0; i < (int) packetData.size(); ++i )
				receivedCorrections.push_back( packetData[i] );

			// process acks in this packet
			net::ReliabilityInfo * reliability_info = static_cast<net::ReliabilityInfo*>( info[net::INFO_Reliability] );
			NET_ASSERT( reliability_info );
			for ( int i = 0; i < reliability_info->num_acks; ++i )
				ProcessAck( reliability_info->acks[i] );
		}
		
		packetData.clear();
	}
	
	void BeforeWrite( const net::TimeBase & timeBase, net::ProtocolInfo ** info )
	{
		RemoveAckedCorrections();
		
		packetData.clear();

		std::vector<Correction> & sendQueue = GetSendQueue();
		for ( int i = 0; i < (int) sendQueue.size(); ++i )
		{
			NET_ASSERT( !sendQueue[i].acked );
			if ( (int) packetData.size() == MaxCorrectionsPerPacket )
				break;
			if ( sendQueue[i].framesSinceLastSent >= CorrectionResendFrames )
				packetData.push_back( sendQueue[i] );
		}
	}
	
	void AfterWrite( const net::TimeBase & timeBase, net::ProtocolInfo ** info, int packetBytes, bool commit )
	{
		if ( commit )
		{
			if ( commit && packetData.size() )
			{
				// add correction info mapping this packet to the set of corrections it contained (for acks)
				net::ReliabilityInfo * reliability_info = static_cast<net::ReliabilityInfo*>( info[net::INFO_Reliability] );
				NET_ASSERT( reliability_info );
				const uint16_t sequence = reliability_info->sequence;
				int index = sequence % MaxPacketInfos;
				CorrectionPacketInfo & packetInfo = this->packetInfo[index];
				packetInfo.valid = 1;
				packetInfo.sequence = sequence;
				packetInfo.numCorrections = packetData.size();
				for ( int i = 0; i < (int) packetData.size(); ++i )
				{
					packetInfo.corrections[i].id = packetData[i].id;
					packetInfo.corrections[i].counter = packetData[i].counter;
				}
				
				// reset frames since last sent to zero for all sent corrections
				for ( int i = 0; i < (int) packetData.size(); ++i )
				{
					Correction * correction = FindCorrection( packetData[i].id, packetData[i].counter );
					NET_ASSERT( correction );
					correction->framesSinceLastSent = 0;
				}
			}
		}

		packetData.clear();
	}

	void ProcessAck( uint16_t sequence )
	{
		CorrectionPacketInfo * packetInfo = FindPacketInfo( sequence );
		if ( !packetInfo )
			return;
		for ( int i = 0; i < packetInfo->numCorrections; ++i )
		{
			const ObjectId id = packetInfo->corrections[i].id;
			const uint16_t counter = packetInfo->corrections[i].counter;
			Correction * correction = FindCorrection( id, counter );
			if ( correction )
			{
				#ifdef DEBUG_CORRECTIONS
				printf( "ack correction %d [%d]\n", id, counter );
				#endif
				correction->acked = 1;
			}
		}
		packetInfo->valid = 0;		// acked
	}
	
	void RemoveAckedCorrections()
	{
		// pass over send queue and count how many acked entries exist
		int numAcked = 0;
		std::vector<Correction> & sendQueue = GetSendQueue();
		for ( int i = 0; i < (int) sendQueue.size(); ++i )
			numAcked += sendQueue[i].acked;
		
		// remove acked entries by copying across then swapping to other queue
		// easier to code and probably faster than removing the acked entries in-place, i think
		if ( numAcked > 0 )
		{
			std::vector<Correction> & dest = this->sendQueue[ ( sendQueueIndex+1 ) & 1 ];
			dest.clear();
			for ( int i = 0; i < (int) sendQueue.size(); ++i )
			{
				if ( !sendQueue[i].acked )
					dest.push_back( sendQueue[i] );
			}
			sendQueue.clear();
			sendQueueIndex++;
		}
	}
	
	CorrectionPacketInfo * FindPacketInfo( uint16_t sequence )
	{
		int index = sequence % MaxPacketInfos;
		if ( packetInfo[index].valid && packetInfo[index].sequence == sequence )
			return &packetInfo[index];
		else
			return NULL;
	}

private:

	std::vector<Correction> & GetSendQueue()
	{
		return sendQueue[sendQueueIndex&1];
	}
	
	Correction * FindCorrection( ObjectId id, uint16_t counter )
	{
		std::vector<Correction> & sendQueue = GetSendQueue();
		for ( int i = 0; i < (int) sendQueue.size(); ++i )
		{
			if ( sendQueue[i].id == id && sendQueue[i].counter == counter )
			{
				if ( !sendQueue[i].acked )
					return &sendQueue[i];
				else
					return NULL;
			}
		}
		return NULL;
	}

	int sendQueueIndex;					
	std::vector<Correction> sendQueue[2];					// dual send queues to allow copying to strip out acked entries
	std::vector<Correction> packetData;						// packet data in flight (stored here until committed)
	std::vector<Correction> receivedCorrections;			// received corrections for user to read

	CorrectionPacketInfo packetInfo[MaxPacketInfos];		// committed packet infos for acks
};

#endif

#ifndef DISABLE_PUSH_PULL

struct StateObjectInfo
{
	ObjectId id;									// id of the object included in the packet
	int32_t position_x;							    // absolute x position of the object (*.resolution)
	int32_t position_y;							    // absolute y position of the object
	int32_t position_z;							    // absolute z position of the object
	uint32_t orientation;							// compressed orientation
};

struct StatePacketInfo
{
	StatePacketInfo()
	{
		sequence = 0;
		valid = 0;
		numObjects = 0;
	}
	
 	uint32_t sequence : 16;							// sequence # this info applies to
	uint32_t valid : 1;								// 1 if this packet info is valid
	uint32_t numObjects : 15;						// number of objects updates included in this packet
	StateObjectInfo objects[MaxObjectsPerPacket];
};

struct StateConfirmInfo
{
	ObjectId id;									// this id of the object that was confirmed
	uint16_t sequence;								// the sequence number of the packet that is being confirmed
	int32_t position_x;							    // absolute x position that is being confirmed
	int32_t position_y;							    // absolute y position that is being confirmed
	int32_t position_z;							    // absolute z position that is being confirmed
	uint32_t orientation;							// orientation of object which is being confirmed
};

class StateManager : public net::StateManager
{
public:
	
	StateManager( net::StateFactory & factory, const net::StateConfig & config = net::StateConfig() )
		: net::StateManager( factory, config )
	{
		numConfirmInfos = 0;
	}
	
 	virtual void AfterRead( const net::TimeBase & timeBase, net::ProtocolInfo ** info, int packetBytes, bool commit )
	{
		if  ( commit )
		{
			net::ReliabilityInfo * reliability_info = static_cast<net::ReliabilityInfo*>( info[net::INFO_Reliability] );
			NET_ASSERT( reliability_info );
			for ( int i = 0; i < reliability_info->num_acks; ++i )
				ProcessAck( reliability_info->acks[i] );
		}
		
		net::StateManager::AfterRead( timeBase, info, packetBytes, commit );
	}
	
	void AfterWrite( const net::TimeBase & timeBase, net::ProtocolInfo ** info, int packetBytes, bool commit )
	{
		if ( commit && pendingPacketInfo.valid )
		{
			net::ReliabilityInfo * reliability_info = static_cast<net::ReliabilityInfo*>( info[net::INFO_Reliability] );
			NET_ASSERT( reliability_info );
			const uint16_t sequence = reliability_info->sequence;
			int index = sequence % MaxPacketInfos;
			packetInfo[index] = pendingPacketInfo;
			packetInfo[index].sequence = sequence;
		}
		pendingPacketInfo.valid = 0;

		net::StateManager::AfterWrite( timeBase, info, packetBytes, commit );
	}

	void AddConfirmObjects( const StatePacketInfo & packetInfo )
	{
		NET_ASSERT( pendingPacketInfo.valid == 0 );
		pendingPacketInfo = packetInfo;
		pendingPacketInfo.valid = 1;
	}
	
	int GetNumConfirmInfos() const
	{
		return numConfirmInfos;
	}

 	const StateConfirmInfo * GetConfirmInfos() const
	{
		return confirmInfo;
	}
	
	void ResetConfirmInfos()
	{
		numConfirmInfos = 0;
	}
	
protected:
	
	void ProcessAck( uint16_t sequence )
	{
		StatePacketInfo * packetInfo = FindPacketInfo( sequence );
		if ( !packetInfo )
			return;
		for ( int i = 0; i < packetInfo->numObjects; ++i )
		{
			NET_ASSERT( numConfirmInfos < MaxConfirmInfos );
			StateObjectInfo & objectInfo = packetInfo->objects[i];
			StateConfirmInfo & confirmInfo = this->confirmInfo[numConfirmInfos++];
			confirmInfo.sequence = sequence;
			confirmInfo.id = objectInfo.id;
			confirmInfo.position_x = objectInfo.position_x;
			confirmInfo.position_y = objectInfo.position_y;
			confirmInfo.position_z = objectInfo.position_z;
			confirmInfo.orientation = objectInfo.orientation;
			#ifdef DEBUG_CONFIRMATION
			printf( "object %d confirmed in packet %d\n", objectInfo.id, sequence );
			#endif
		}
		packetInfo->valid = 0;		// acked
	}
	
	StatePacketInfo * FindPacketInfo( uint16_t sequence )
	{
		int index = sequence % MaxPacketInfos;
		if ( packetInfo[index].valid && packetInfo[index].sequence == sequence )
			return &packetInfo[index];
		else
			return NULL;
	}

private:
		
	StatePacketInfo pendingPacketInfo;
	
	StatePacketInfo packetInfo[MaxPacketInfos];

	int numConfirmInfos;
	StateConfirmInfo confirmInfo[MaxConfirmInfos];
};

#endif

#endif // DISABLE_NETWORKING

// ==================================================================================================

typedef game::Instance<hypercube::DatabaseObject, hypercube::ActiveObject> GameInstance;

class MultiplayerDemo : public Demo, public game::Listener
{
private:

	// local game instance + simulation
	
 	GameInstance * gameInstance;
	GameWorkerThread workerThread;

#ifdef HAS_OPENGL
	
	// rendering
	
	view::Packet viewPacket;
	view::ObjectManager viewObjectManager;
	render::Render * render;
	float t;
	Camera camera;
	math::Vector origin;
	float simTime;
	float renderTime;
	
#endif
	
#ifndef DISABLE_NETWORKING
	
	// networking
	
	uint32_t frame;
	net::TimeBase timeBase;
	net::Transport * transport;
	net::Protocol * protocol[MaxNodes];
	StateFactory * stateFactory;
	engine::PrioritySet prioritySet;
	bool connected;
	bool receivedPacketFromNode[MaxNodes];
	int numSendObjects[MaxNodes];
	int sentActiveObjects[MaxNodes][MaxObjectsPerPacket];
			
#endif
			
public:

	enum { steps = 1024 };

	MultiplayerDemo()
	{
		game::Config config;
		config.maxObjects = steps * steps + MaxPlayers + 1;
		config.deactivationTime = 0.5f;
		config.cellSize = 4.0f;
		config.cellWidth = steps / config.cellSize + 2;
		config.cellHeight = config.cellWidth;
		config.activationDistance = ActivationDistance;
		config.z_min = 0.0f;
		config.z_max = PositionBoundZ;
		config.simConfig.ERP = 0.1f;
		config.simConfig.CFM = 0.001f;
		config.simConfig.MaxIterations = 12;
		config.simConfig.MaximumCorrectingVelocity = 100.0f;
		config.simConfig.ContactSurfaceLayer = 0.05f;
		config.simConfig.Elasticity = 0.3f;
		config.simConfig.LinearDrag = 0.01f;
		config.simConfig.AngularDrag = 0.01f;
		config.simConfig.Friction = 200.0f;

		gameInstance = new game::Instance<hypercube::DatabaseObject, hypercube::ActiveObject> ( config );
		
		#ifdef HAS_OPENGL
		t = 0.0f;
		origin = math::Vector(0,0,0);
		render = NULL;
		renderTime = 0.0f;
		simTime = 0.0f;
		#endif
		
		#ifndef DISABLE_NETWORKING
		CreateProtocol();
		InitializeTransport();
		#endif
	}
	
	~MultiplayerDemo()
	{
		#ifndef DISABLE_NETWORKING
		DestroyProtocol();
		ShutdownTransport();
		#endif
				
		#ifdef HAS_OPENGL
		delete render;
		#endif

		delete gameInstance;
	}
	
	void InitializeWorld()
	{
		gameInstance->InitializeBegin();

		gameInstance->AddPlane( math::Vector(0,0,1), 0 );

		AddCube( gameInstance, 1, math::Vector(-5,+5,10) );
		AddCube( gameInstance, 1, math::Vector(+5,+5,10) );
		AddCube( gameInstance, 1, math::Vector(-5,-5,10) );
		AddCube( gameInstance, 1, math::Vector(+5,-5,10) );
		
		// NETHACK: todo - debug issue with activation slide
		/*
		const float z = hypercube::NonPlayerCubeSize / 2;
		for ( int i = 0; i < 1; ++i )
		{
			AddCube( gameInstance, 0, math::Vector(i,0,z) );
		}
		*/
	
		const int border = 10.0f;
		const float origin = -steps / 2 + border;
		const float z = hypercube::NonPlayerCubeSize / 2;
		const int count = steps - border * 2;
		for ( int y = 0; y < count; ++y )
			for ( int x = 0; x < count; ++x )
				AddCube( gameInstance, 0, math::Vector(x+origin,y+origin,z) );
		
		gameInstance->InitializeEnd();

		gameInstance->SetFlag( game::FLAG_Push );
		gameInstance->SetFlag( game::FLAG_Pull );
		
		gameInstance->SetListener( this );
		
		#ifdef DISABLE_NETWORKING
		gameInstance->OnPlayerJoined( 0 );
		gameInstance->SetPlayerFocus( 0, 1 );
		gameInstance->SetLocalPlayer( 0 );
		#endif
		
		#ifdef DEBUG_SIZEOF_STATE
		printf( "cube state is %d bytes\n", (int) sizeof( CubeState ) );
		printf( "player state is %d bytes\n", (int) sizeof( PlayerState ) );
		#endif
	}
	
	void InitializeRender( int displayWidth, int displayHeight )
	{
		#ifdef HAS_OPENGL
		render = new render::Render( displayWidth, displayHeight );
		#endif
	}
    
	void ResizeDisplay( int displayWidth, int displayHeight )
	{
		#ifdef HAS_OPENGL
		render->ResizeDisplay( displayWidth, displayHeight );
		#endif
	}
	
	void AddCube( game::Instance<hypercube::DatabaseObject, hypercube::ActiveObject> * gameInstance, int player, const math::Vector & position )
	{
		hypercube::DatabaseObject object;
		CompressPosition( position, object.position );
		CompressOrientation( math::Quaternion(1,0,0,0), object.orientation );
		object.dirty = player;
		object.enabled = player;
		object.session = 0;
		object.player = player;
		ObjectId id = gameInstance->AddObject( object, position.x, position.y );
		if ( player )
			gameInstance->DisableObject( id );
	}
	
	void OnObjectActivated( ObjectId id, int activeIndex )
	{
		#ifdef DEBUG_ACTIVATION
		printf( "object %d activated [%d]\n", id, activeIndex );
		#endif
		
		#ifdef DISABLE_NETWORKING

			// ...

		#else
		
			prioritySet.AddObject( activeIndex );
		
			if ( IsServer() )
			{
				// IMPORTANT: on the server assign a random session id to each object the first time it activates
				// the server will not accept updates from a client unless the session id matches
				hypercube::ActiveObject & activeObject = gameInstance->GetActiveObject( activeIndex );
				if ( activeObject.session == 0 )
				{
					activeObject.session = 1 + ( rand() % ( (1<<SessionIdBits) - 1 ) );
					#ifdef DEBUG_SESSION
					printf( "random session for object %d: %d\n", id, (int)activeObject.session );
					#endif
				}
			}
			else
			{
				// IMPORTANT: on client don't enable object until server has a chance to send us an update
				// otherwise we get a nasty pop for objects that were deactivated hanging in the air
				hypercube::ActiveObject & activeObject = gameInstance->GetActiveObject( activeIndex );
				if ( !activeObject.player )
					activeObject.enabled = false;
			}

		#endif
	}
	
	void OnObjectDeactivated( ObjectId id, int activeIndex )
	{
		#ifdef DEBUG_ACTIVATION
		printf( "object %d deactivated [%d]\n", id, activeIndex );
		#endif
		#ifndef DISABLE_NETWORKING
		prioritySet.RemoveObject( activeIndex );
		#endif
	}

	void ProcessInput( const platform::Input & input )
	{
		#ifndef DISABLE_NETWORKING
		if ( !IsServer() )
		#endif
		{
			// pass input to game instance
		
			game::Input gameInput;
			gameInput.left = input.left ? 1.0f : 0.0f;
			gameInput.right = input.right ? 1.0f : 0.0f;
			gameInput.up = input.up ? 1.0f : 0.0f;
			gameInput.down = input.down ? 1.0f : 0.0f;
			gameInput.push = input.space ? 1.0f : 0.0f;
			gameInput.pull = input.z ? 1.0f : 0.0f;
		
			#ifndef DISABLE_NETWORKING
			int localPlayerId = GetLocalPlayerId();
			#else
			int localPlayerId = 0;
			#endif
			if ( localPlayerId != -1 )
				gameInstance->SetPlayerInput( localPlayerId, gameInput );
		}
	}
	
	void Clamp( hypercube::QuantizedObject & quantized )
	{
		quantized.position_x = math::clamp( quantized.position_x, -PositionBoundXY, +PositionBoundXY );
		quantized.position_y = math::clamp( quantized.position_y, -PositionBoundXY, +PositionBoundXY );
		quantized.position_z = math::clamp( quantized.position_z, 0, +PositionBoundZ );
		
		quantized.linear_velocity_x = math::clamp( quantized.linear_velocity_x, -MaxLinearVelocity, +MaxLinearVelocity );
		quantized.linear_velocity_y = math::clamp( quantized.linear_velocity_y, -MaxLinearVelocity, +MaxLinearVelocity );
		quantized.linear_velocity_z = math::clamp( quantized.linear_velocity_z, -MaxLinearVelocity, +MaxLinearVelocity );

		if ( quantized.player )
		{
			quantized.angular_velocity_x = math::clamp( quantized.angular_velocity_x, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
			quantized.angular_velocity_y = math::clamp( quantized.angular_velocity_y, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
			quantized.angular_velocity_z = math::clamp( quantized.angular_velocity_z, -MaxPlayerAngularVelocity, +MaxPlayerAngularVelocity );
		}
		else
		{
			quantized.angular_velocity_x = math::clamp( quantized.angular_velocity_x, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
			quantized.angular_velocity_y = math::clamp( quantized.angular_velocity_y, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
			quantized.angular_velocity_z = math::clamp( quantized.angular_velocity_z, -MaxCubeAngularVelocity, +MaxCubeAngularVelocity );
		}
	}
		
	void Quantize()
	{
		const int numActiveObjects = gameInstance->GetNumActiveObjects();
		if ( numActiveObjects == 0 )
			return;
		hypercube::ActiveObject * activeObjects = gameInstance->GetActiveObjects();
		for ( int i = 0; i < numActiveObjects; ++i )
		{
			// quantize the object
			hypercube::ActiveObject & activeObject = activeObjects[i];
			hypercube::QuantizedObject quantized;
			quantized.Load( activeObject, Resolution );
			Clamp( quantized );
			quantized.Store( activeObject, Resolution );
			gameInstance->MoveActiveObject( &activeObject, false );
			
			// if the object is enabled then clear the confirmed bit
			if ( activeObject.enabled )
				activeObject.confirmed = 0;
		}
	}
	
	void DebugNotAtRest()
	{
		#ifdef DEBUG_NOT_AT_REST
		const int numActiveObjects = gameInstance->GetNumActiveObjects();
		if ( numActiveObjects > 0 )
		{
			printf( "--------------------------\n" );
			const hypercube::ActiveObject * activeObjects = gameInstance->GetActiveObjects();
			for ( int i = 0; i < numActiveObjects; ++i )
			{
				if ( activeObjects[i].enabled )
				{
					printf( "not at rest %d: linvel = (%f,%f,%f), angvel = (%f,%f,%f)\n",
						(int) activeObjects[i].id, 
						activeObjects[i].linearVelocity.x, 
						activeObjects[i].linearVelocity.y, 
						activeObjects[i].linearVelocity.z, 
						activeObjects[i].angularVelocity.x, 
						activeObjects[i].angularVelocity.y, 
						activeObjects[i].angularVelocity.z );
				}
			}
			printf( "--------------------------\n" );
		}
		#endif
	}
	
	void Update( float deltaTime )
	{	
		DebugNotAtRest();
		
		Quantize();
		
		#ifndef DISABLE_NETWORKING
		UpdateNetwork( deltaTime );
		Quantize();
		UpdateStats();
		if ( !ShouldUpdateSimulation() )
			return;
		#endif

	#ifdef HAS_OPENGL
		
		// update camera

		#ifndef DISABLE_NETWORKING
		int localPlayerId = GetLocalPlayerId();
		#else
		int localPlayerId = 0;
		#endif
		view::Object * playerCube = viewObjectManager.GetObject( localPlayerId + 1 );
		if ( playerCube )
			origin = playerCube->position + playerCube->positionError;
		else
			origin = math::Vector(0,0,1);
			
		math::Vector lookat = origin - math::Vector(0,0,1);
		
		#ifdef WIDESCREEN
		math::Vector position = lookat + math::Vector(0,-11,5);
		#else
		math::Vector position = lookat + math::Vector(0,-12,6);
		#endif
		
		camera.EaseIn( lookat, position ); 
	
	#endif
	
		// quantize game state before render
		Quantize();
	
		// grab the view packet (previous frame)
		#ifdef HAS_OPENGL
		gameInstance->GetViewPacket( viewPacket );
		t += deltaTime;
		#endif
		
		// start the worker thread for game update
		workerThread.Start( gameInstance );
	}
	
	void Render( float deltaTime, bool shadows )
	{
		#ifdef HAS_OPENGL
		
		platform::Timer timer;
		
		// clear the screen
		render->ClearScreen();
		
		// nothing to render unless we have a local player id
		#ifndef DISABLE_NETWORKING
		if ( GetLocalPlayerId() == -1 )
			return;
		#endif
		
		// update the scene to be rendered
		
		if ( viewPacket.objectCount >= 1 )
		{
			view::ObjectUpdate updates[MaxViewObjects];
			getViewObjectUpdates( updates, viewPacket );
			viewObjectManager.UpdateObjects( updates, viewPacket.objectCount );
		}
		viewObjectManager.ExtrapolateObjects( deltaTime );
		viewObjectManager.Update( deltaTime );

		// render the scene
		
		Cubes cubes;
		viewObjectManager.GetRenderState( cubes );

		int width = render->GetDisplayWidth();
		int height = render->GetDisplayHeight();

		render->BeginScene( 0, 0, width, height );
		setCameraAndLight( render, camera );
		ActivationArea activationArea;
		view::setupActivationArea( activationArea, origin, 5.0f, t );
		render->RenderActivationArea( activationArea, 1.0f );
		render->RenderCubes( cubes );
		#ifdef SHADOWS
		if ( shadows )
		{
			render->RenderCubeShadows( cubes );
			render->RenderShadowQuad();
		}
		#endif
		
		renderTime = timer.delta();
		
		render->EnterScreenSpace();
		render->RenderFrameTime( renderTime, simTime, deltaTime );
		render->LeaveScreenSpace();

		#endif
	}
	
	void WaitForSim()
	{
		workerThread.Join();
		#ifdef HAS_OPENGL
		simTime = workerThread.GetSimTime();
		#endif
	}
		
#ifndef DISABLE_NETWORKING

	void CreateProtocol()
	{
		net::AtomFactoryConfig stateFactoryConfig;
		stateFactoryConfig.maxAtomSize = MaxStateBytes;
	
		stateFactory = new StateFactory( stateFactoryConfig );
	
		for ( int i = 0; i < MaxNodes; ++i )
		{
			net::ProtocolConfig protocolConfig;
			#ifndef DEBUG_JOURNAL
			protocolConfig.journal = 0;
			#endif
			protocol[i] = new net::Protocol( protocolConfig );
		
			net::StateConfig stateConfig;
			stateConfig.maxObjectsPerPacket = MaxObjectsPerPacket;
			stateConfig.maxSerializeBytesPerObject = 64;
		
			ReliabilityManager * reliabilityManager = new ReliabilityManager();
			#ifndef DISABLE_PUSH_PULL
			StateManager * stateManager = new StateManager( *stateFactory, stateConfig );
			#endif

			protocol[i]->AddManager( reliabilityManager );
			#ifndef DISABLE_CORRECTIONS
			protocol[i]->AddManager( new CorrectionManager() );
			#endif
			#ifndef DISABLE_PUSH_PULL
			protocol[i]->AddManager( stateManager );
			#endif
		
			protocol[i]->Lock();
		}
	}
	
	void DestroyProtocol()
	{
		for ( int i = 0; i < MaxNodes; ++i )
		{
			delete protocol[i];
			protocol[i] = NULL;
		}
		
		delete stateFactory;
		stateFactory = NULL;
	}
	
	void InitializeTransport()
	{
		NET_ASSERT( !transport );
		net::Transport::Initialize( net::Transport_LAN, MaxNodes );
		transport = net::Transport::Create();
		NET_ASSERT( transport );
		connected = false;
		memset( receivedPacketFromNode, 0, sizeof( receivedPacketFromNode ) );
	}
	
	void StartTransport( net::Transport::Mode mode, const char name[] )
	{
		NET_ASSERT( transport );
		transport->Start( mode, name );
		connected = false;
	}
	
	void StopTransport()
	{
		NET_ASSERT( transport );
		transport->Stop();
		connected = false;
	}
	
	void ShutdownTransport()
	{
		if ( transport )
		{
			transport->Stop();
			net::Transport::Destroy( transport );
			transport = NULL;
		}
		net::Transport::Shutdown();
	}
	
	void SendPacket( const net::TimeBase & timeBase, int toNodeId )
	{		
		#ifdef DEBUG_READ_WRITE
		printf( "write packet to node %d\n", toNodeId );
		#endif
		#ifdef DEBUG_JOURNAL
		int packetBytes = MaxPacketBytes;
		uint8_t packet[MaxPacketBytes];
		bool result = protocol[toNodeId]->WritePacket( timeBase, packet, packetBytes, MaxDataBytes, MaxJournalBytes );
		#else
		int packetBytes = MaxDataBytes;
		uint8_t packet[MaxDataBytes]; 
		bool result = protocol[toNodeId]->WritePacket( timeBase, packet, packetBytes, MaxDataBytes, 0 );
		#endif
		assert( result );
		if ( result )
		{
			#ifdef DEBUG_PACKET_LOSS
			if ( frame % 2 == 0 )		// simulated packet loss
			#endif
			{
				// send packet
				transport->SendPacket( toNodeId, packet, packetBytes );
			
				// collect stats
				if ( IsClient() || ( IsServer() && toNodeId != 0 ) )
				{
					if ( packetBytes < stats.minSendPacketBytes )
						stats.minSendPacketBytes = packetBytes;
					if ( packetBytes > stats.maxSendPacketBytes )
						stats.maxSendPacketBytes = packetBytes;
					stats.avgSendPacketBytes += ( packetBytes - stats.avgSendPacketBytes ) * 0.1f;
				}
			}
		}
	}
	
	void SendPackets( const net::TimeBase & timeBase, float deltaTime )
	{
		// send packets every nth frame (@60fps update)
		if ( ( frame % SendRate ) != 0 )
			return;		
			
		// clear send data
		memset( numSendObjects, 0, sizeof( numSendObjects ) );
		memset( sentActiveObjects, 0, sizeof( sentActiveObjects ) );		

		#ifdef DEBUG_SERVER

			// debug server just sends packets back to itself to exercise the push/pull codepath
		
			const int playerId = 0;
			const int toNodeId = 0;
		
			if ( transport->IsConnected() && transport->IsNodeConnected( toNodeId ) )
			{
				#ifndef DISABLE_PUSH_PULL
				PullObjects( deltaTime, playerId, toNodeId );
				#endif

				SendPacket( timeBase, toNodeId );
		
				#ifndef DISABLE_PUSH_PULL
				PostSendPacket( playerId, toNodeId );
				#endif
			}

		#else

			if ( IsServer() )
			{
				// for the moment the server only sends packets to player 0 (node 1)
				// (we need to generalize the activation system to support one zone per-player
				//  before we can have the server determining set of relevant objects for multiple players)

				// IMPORTANT: we must not send packets to the node until we have first received a packet from them
				// this avoids the firewall freaking out and thinking it's an incoming connection instead of outgoing...

				const int playerId = 0;
				const int toNodeId = playerId + 1;

				if ( transport->IsConnected() && transport->IsNodeConnected( toNodeId ) && receivedPacketFromNode[toNodeId] )
				{
					#ifndef DISABLE_PUSH_PULL
					PullObjects( deltaTime, playerId, toNodeId );
					#endif

					SendPacket( timeBase, toNodeId );

					#ifndef DISABLE_PUSH_PULL
					PostSendPacket( playerId, toNodeId );
					#endif
				}
			}
			else if ( IsClient() )
			{
				// client sends packets to server node
				
				const int localPlayerId = GetLocalPlayerId();
				const int serverNodeId = 0;
				
				if ( transport->IsConnected() && localPlayerId != -1 && transport->IsNodeConnected( serverNodeId ) )
				{
					#ifndef DISABLE_PUSH_PULL
					PullObjects( deltaTime, localPlayerId, serverNodeId );
					#endif

					SendPacket( timeBase, serverNodeId );

					#ifndef DISABLE_PUSH_PULL
					PostSendPacket( localPlayerId, serverNodeId );
					#endif
				}
			}

		#endif
	}
	
	void ReceivePackets( const net::TimeBase & timeBase )
	{		
		int fromNodeId;
		#ifdef DEBUG_JOURNAL
		uint8_t packet[MaxPacketBytes];
		while ( int packetBytes = transport->ReceivePacket( fromNodeId, packet, MaxPacketBytes ) )
		#else
		uint8_t packet[MaxDataBytes];
		while ( int packetBytes = transport->ReceivePacket( fromNodeId, packet, MaxDataBytes ) )
		#endif
		{
			receivedPacketFromNode[fromNodeId] = true;
			#ifdef DEBUG_READ_WRITE
			printf( "read packet from node %d\n", fromNodeId );
			#endif
			bool result = 
			#ifdef DEBUG_JOURNAL
			protocol[fromNodeId]->ReadPacket( timeBase, packet, packetBytes, MaxDataBytes, MaxJournalBytes );
			#else
			protocol[fromNodeId]->ReadPacket( timeBase, packet, packetBytes, MaxDataBytes, 0 );
			#endif

			if ( result )
			{
				if ( packetBytes < stats.minRecvPacketBytes )
					stats.minRecvPacketBytes = packetBytes;
				if ( packetBytes > stats.maxRecvPacketBytes )
					stats.maxRecvPacketBytes = packetBytes;
				stats.avgRecvPacketBytes += ( packetBytes - stats.avgRecvPacketBytes ) * 0.1f;
			}
		}
	}
	
#ifndef DISABLE_PUSH_PULL
	
	void ProcessConfirmations()
	{
		if ( !transport->IsConnected() )
			return;
		
		for ( int playerId = 0; playerId < MaxPlayers; ++playerId )
		{			
			const int nodeId = playerId + 1;
	
			if ( !transport->IsNodeConnected( nodeId ) )
				continue;

			StateManager * stateManager = static_cast<StateManager*>( protocol[nodeId]->GetManager( PROTOCOL_State ) );

			const int numConfirmInfos = stateManager->GetNumConfirmInfos();
			const StateConfirmInfo * confirmInfos = stateManager->GetConfirmInfos();
			for ( int i = 0; i < numConfirmInfos; ++i )
			{
				const StateConfirmInfo & confirmInfo = confirmInfos[i];
				hypercube::ActiveObject * activeObject = gameInstance->FindActiveObject( confirmInfo.id );
				if ( activeObject )
				{
					uint32_t orientation;
					int32_t position_x;
					int32_t position_y;
					int32_t position_z;
					CompressOrientation( activeObject->orientation, orientation );
					QuantizeVector( activeObject->position, position_x, position_y, position_z, Resolution );
					
					if ( confirmInfo.orientation == orientation && 
					     confirmInfo.position_x == position_x &&
						 confirmInfo.position_y == position_y && 
						 confirmInfo.position_z == position_z )
					{
						#ifdef DEBUG_CONFIRMATION
						printf( "confirmed object %d\n", (int) activeObject->id );
						#endif
						activeObject->confirmed = 1;
					}
				}
			}
			
			stateManager->ResetConfirmInfos();
		}
		
		#ifdef DEBUG_UNCONFIRMED
		const int numActiveObjects = gameInstance->GetNumActiveObjects();
		if ( numActiveObjects > 0 )
		{
			printf( "--------------------------\n" );
			const hypercube::ActiveObject * activeObjects = gameInstance->GetActiveObjects();
			for ( int i = 0; i < numActiveObjects; ++i )
			{
				if ( !activeObjects[i].confirmed )
				{
					printf( "unconfirmed %d (%s)\n", (int) activeObjects[i].id, ( activeObjects[i].authority == MaxPlayers ) ? "white" : "red" );
				}
			}
			printf( "--------------------------\n" );
		}
		#endif
	}
	
#endif
	
	bool AnyPlayerJoined()
	{
		#ifdef DISABLE_NETWORKING
		return true;
		#else
		if ( !transport->IsConnected() )
			return false;
		for ( int i = 0; i < MaxPlayers; ++i )
		{
			if ( transport->IsNodeConnected( i + 1 ) )
				return true;
		}
		return false;
		#endif
	}
	
	void PlayerJoined( int playerId )
	{
		printf( "player %d joined the game\n", playerId );
		gameInstance->OnPlayerJoined( playerId );
		gameInstance->SetPlayerFocus( playerId, playerId + 1 );		// IMPORTANT: object ids for player cubes is [1,4]
	}
	
	void PlayerLeft( int playerId )
	{
		printf( "player %d left the game\n", playerId );
		gameInstance->OnPlayerLeft( playerId );
	}
	
	void UpdatePriority( float deltaTime, int toNodeId, int playerId, ObjectId playerFocus, float origin_x, float origin_y, const hypercube::ActiveObject * activeObjects, int numActiveObjects )
	{
		// accumulate priority for active objects
		const int desiredAuthority = IsClient() ? playerId : MaxPlayers;
		for ( int i = 0; i < numActiveObjects; ++i )
		{
			const hypercube::ActiveObject & activeObject = activeObjects[i];
			
			float scale = 1.0f;

			// boost priority based on authority:
			// 1. client -> server higher priority red cubes
			// 2. server -> client higher priority white cubes
			scale *= 1.0f + 1.0f * ( activeObject.authority == desiredAuthority );
			
			// boost priority for objects that have just been enabled
			// eg. objects which have gone from at rest to moving without being synced
			scale *= 1.0f + 2.0f * ( activeObject.justEnabled );
			
			// boost priority for objects just activated
			// 1. client -> server if an object is activated send it (drives corrections)
			// 2. server -> client boost only if object is "dirty" (has moved from initial pos)
			if ( IsClient() || ( IsServer() && activeObject.dirty ) )
				scale *= 1.0f + 2.0f * ( activeObject.justActivated );
			
			// accumulate deltaTime*scale
			float accumulator = prioritySet.GetAccumulator( i );
			accumulator += deltaTime * scale;
			
			// always include the local player in the packet
			accumulator *= 1.0f + 1000000.0f * ( activeObject.id == playerFocus );

			// do not send cubes which are outside relative position bound
			// we compress within xy bounds of origin point, if the object is outside
			// these bounds then we cannot send it! (priority = 0 objects are never sent)
			int dx = math::floor( activeObject.position.x * Resolution + 0.5f ) - origin_x;
			int dy = math::floor( activeObject.position.y * Resolution + 0.5f ) - origin_y;
			if ( dx < -RelativePositionBound || dx > +RelativePositionBound ||
			     dy < -RelativePositionBound || dy > +RelativePositionBound )
			{
				accumulator = 0.0f;
			}

			// do not send confirmed objects.
			// confirmed objects are at rest and we know (via acks) the other side has
			// received a state update with current position at rest.
			#ifndef DISABLE_CONFIRMATION
			if ( activeObject.confirmed )
				accumulator = 0.0f;
			#endif

			// there is no point sending red objects on the server to the client
			// the client has authority over red objects, therefore will not accept
			// updates from the server anyway (exception is if we want to *correct* client)
			if ( IsServer() && activeObject.authority == toNodeId - 1 )
				accumulator = 0.0f;

			prioritySet.SetAccumulator( i, accumulator );
		}
		
		// sort objects by priority
		prioritySet.SortObjects();
	}
	
#ifndef DISABLE_PUSH_PULL
	
	void PullObjects( float deltaTime, int playerId, int toNodeId )
	{
		NET_ASSERT( playerId >= 0 );
		NET_ASSERT( playerId < MaxPlayers );
		NET_ASSERT( toNodeId >= 0 );
		NET_ASSERT( toNodeId < MaxNodes );
		NET_ASSERT( transport );
		NET_ASSERT( transport->IsConnected() );
		NET_ASSERT( transport->IsNodeConnected( toNodeId ) );
		
		// if there are no active objects then there is nothing to pull
		const int numActiveObjects = gameInstance->GetNumActiveObjects();
		if ( numActiveObjects == 0 )
			return;

		// grab information about active objects for player
		const ObjectId playerFocus = gameInstance->GetPlayerFocus( playerId );
		const math::Vector & origin = gameInstance->GetOrigin();
		const hypercube::ActiveObject * activeObjects = gameInstance->GetActiveObjects();
		const int origin_x = (int) math::floor( origin.x * Resolution + 0.5f );
		const int origin_y = (int) math::floor( origin.y * Resolution + 0.5f );
		
		// update priority for objects
		UpdatePriority( deltaTime, toNodeId, playerId, playerFocus, origin_x, origin_y, activeObjects, numActiveObjects );
		
		// grab n most important objects
		#ifdef DEBUG_PUSH_PULL
		printf( "--------------------------------------\n" );
		printf( "pull objects for node %d:\n", toNodeId );
		#endif
		int numObjects = 0;
		net::State * state[MaxObjectsPerPacket];
		for ( int i = 0; i < numActiveObjects; ++i )
		{
			float priority;
			int activeIndex = prioritySet.GetSortedObject( i, priority );
			if ( priority > 0.0f )
			{
				const hypercube::ActiveObject & activeObject = activeObjects[activeIndex];
				#ifdef DEBUG_PUSH_PULL
				printf( " + pull object %d: %f [%d]\n", (int)activeObject.id, priority, activeIndex );
				#endif
				
				CubeState * cubeState = NULL;
				PlayerState * playerState = NULL;
				
				if ( activeObject.player )
				{
					playerState = static_cast<PlayerState*>( stateFactory->Create( STATE_Player ) );
					cubeState = static_cast<CubeState*>( playerState );
				}
				else
				{
					cubeState = static_cast<CubeState*>( stateFactory->Create( STATE_Cube ) );
				}
				
				NET_ASSERT( cubeState );

				if ( playerState )
				{
					int playerId = (int) activeObject.id - 1;
					NET_ASSERT( playerId >= 0 );
					NET_ASSERT( playerId < MaxPlayers );
					playerState->frame = gameInstance->GetPlayerFrame( playerId );
					gameInstance->GetPlayerInput( playerId, playerState->input );
				}

				cubeState->id = activeObject.id;
				cubeState->enabled = activeObject.enabled;
				cubeState->authority = activeObject.authority;
				#ifndef DISABLE_SESSION_ID
				cubeState->session = activeObject.session;
				#endif

				hypercube::QuantizedObject quantized;
				quantized.Load( activeObject, Resolution );

				cubeState->position_x = quantized.position_x;
				cubeState->position_y = quantized.position_y;
				cubeState->position_z = quantized.position_z;

				cubeState->orientation = quantized.orientation;				

				cubeState->linear_velocity_x = quantized.linear_velocity_x;
				cubeState->linear_velocity_y = quantized.linear_velocity_y;
				cubeState->linear_velocity_z = quantized.linear_velocity_z;

				cubeState->angular_velocity_x = quantized.angular_velocity_x;
				cubeState->angular_velocity_y = quantized.angular_velocity_y;
				cubeState->angular_velocity_z = quantized.angular_velocity_z;
				
				NET_ASSERT( numObjects < MaxObjectsPerPacket );
				NET_ASSERT( toNodeId < MaxNodes );
				
				state[numObjects] = cubeState;
				sentActiveObjects[toNodeId][numObjects] = activeIndex;

				numObjects++;

				if ( numObjects == MaxObjectsPerPacket )
					break;
			}
		}
		numSendObjects[toNodeId] = numObjects;
		#ifdef DEBUG_PUSH_PULL
		printf( "--------------------------------------\n" );
		#endif
				
		if ( numObjects > 0 )
		{
			// create state header with frame # and origin
			StateHeader * stateHeader = static_cast<StateHeader*>( stateFactory->CreateStateHeader() );
			NET_ASSERT( stateHeader );
			stateHeader->origin_x = (int) math::floor( origin.x * Resolution + 0.5f );
			stateHeader->origin_y = (int) math::floor( origin.y * Resolution + 0.5f );
			
			// queue objects to be sent to node via state manager (will get included in next packet sent)
			StateManager * stateManager = static_cast<StateManager*>( protocol[toNodeId]->GetManager( PROTOCOL_State ) );
			stateManager->Send( stateHeader, state, numObjects );
		
			// add objects to be confirmed
			#ifndef DISABLE_CONFIRMATION
			if ( IsServer() )
			{
				StatePacketInfo packetInfo;
				for ( int i = 0; i < numObjects; ++i )
				{
					CubeState * cubeState = static_cast<CubeState*>( state[i] );
					if ( cubeState->authority == MaxPlayers && cubeState->enabled == 0 )
					{
						StateObjectInfo & objectInfo = packetInfo.objects[packetInfo.numObjects];
						objectInfo.id = cubeState->id;
						objectInfo.position_x = cubeState->position_x;
						objectInfo.position_y = cubeState->position_y;
						objectInfo.position_z = cubeState->position_z;
						objectInfo.orientation = cubeState->orientation;
						packetInfo.numObjects++;
					}
				}

				if ( packetInfo.numObjects > 0 )
				{
					StateManager * stateManager = static_cast<StateManager*>( protocol[toNodeId]->GetManager( PROTOCOL_State ) );
					stateManager->AddConfirmObjects( packetInfo );
					#ifdef DEBUG_CONFIRMATION
					printf( "add %d confirm objects\n", packetInfo.numObjects );
					#endif
				}
			}
			#endif
		}
	}
	
	void PostSendPacket( int playerId, int toNodeId )
	{
		NET_ASSERT( playerId >= 0 );
		NET_ASSERT( playerId < MaxPlayers );
		NET_ASSERT( toNodeId >= 0 );
		NET_ASSERT( toNodeId < MaxNodes );

		// if no objects were sent then there is nothing to do
		if ( numSendObjects[toNodeId] == 0 )
			return;
		
		// clear priority accumulator for sent objects
		// (we don't know which ones were sent until *after* we serialize write the packet)
		#ifdef DEBUG_PRIORITY
		printf( "--------------------------------------\n" );
		#endif
		StateManager * stateManager = static_cast<StateManager*>( protocol[toNodeId]->GetManager( PROTOCOL_State ) );
		const bool * sent = stateManager->GetSent();
		hypercube::ActiveObject * activeObjects = gameInstance->GetActiveObjects();
		for ( int i = 0; i < numSendObjects[toNodeId]; ++i )
		{
			if ( sent[i] )
			{
				int activeIndex = sentActiveObjects[toNodeId][i];
				prioritySet.SetAccumulator( activeIndex, 0.0f );
				#ifdef DEBUG_PRIORITY
				printf( "reset accumulator for object %d [%d]\n", (int) activeObjects[activeIndex].id, activeIndex );
				#endif
				hypercube::ActiveObject & activeObject = activeObjects[activeIndex];
				activeObject.justEnabled = 0;
				activeObject.justActivated = 0;
			}
		}
		#ifdef DEBUG_PRIORITY
		printf( "--------------------------------------\n" );
		#endif
	}
	
	void CubeStateToActiveObject( const CubeState & cubeState, hypercube::ActiveObject & activeObject )
	{
		hypercube::QuantizedObject quantized;
		quantized.Load( activeObject, Resolution );
		
		quantized.position_x = cubeState.position_x;
		quantized.position_y = cubeState.position_y;
		quantized.position_z = cubeState.position_z;

		quantized.orientation = cubeState.orientation;
		
		if ( cubeState.enabled )
		{
			quantized.linear_velocity_x = cubeState.linear_velocity_x;
			quantized.linear_velocity_y = cubeState.linear_velocity_y;
			quantized.linear_velocity_z = cubeState.linear_velocity_z;

			quantized.angular_velocity_x = cubeState.angular_velocity_x;
			quantized.angular_velocity_y = cubeState.angular_velocity_y;
			quantized.angular_velocity_z = cubeState.angular_velocity_z;
		}
		else
		{
			quantized.linear_velocity_x = 0;
			quantized.linear_velocity_y = 0;
			quantized.linear_velocity_z = 0;

			quantized.angular_velocity_x = 0;
			quantized.angular_velocity_y = 0;
			quantized.angular_velocity_z = 0;
		}

		activeObject.enabled = cubeState.enabled;
		activeObject.authority = cubeState.authority;
		
		quantized.Store( activeObject, Resolution );
	}

	void CubeStateToDatabaseObject( const CubeState & cubeState, hypercube::DatabaseObject & databaseObject, float & x, float & y )
	{
		math::Vector position;
		UnquantizeVector( cubeState.position_x, cubeState.position_y, cubeState.position_z, position, Resolution );
		
		x = position.x;
		y = position.y;
		
		CompressPosition( position, databaseObject.position );
		
		databaseObject.orientation = cubeState.orientation;
		databaseObject.enabled = cubeState.enabled;
		
		#ifndef DISABLE_SESSION_ID
		databaseObject.session = cubeState.session;
		#endif
	}
	
	#ifndef DISABLE_CORRECTIONS

	void PushCorrection( const Correction & correction )
	{		
		NET_ASSERT( IsClient() );
		hypercube::ActiveObject * activeObject = gameInstance->FindActiveObject( correction.id );
		if ( activeObject )
		{
			UnquantizeVector( correction.position_x, correction.position_y, correction.position_z, activeObject->position, Resolution );
			DecompressOrientation( correction.orientation, activeObject->orientation );
			gameInstance->MoveActiveObject( activeObject, true );
		}
	}
	
	void DetectServerCorrection( const StateHeader & header, const CubeState & cubeState, int fromNodeId )
	{		
		// first, only consider updates sent *inside* client activation circle as being eligible for corrections
		// the other objects outside the circle (trailing at high speed) are not important to correct, because
		// they will be deactivated soon by the client unless he moves them back into his circle
		NET_ASSERT( IsServer() );
		CorrectionManager * correctionManager = static_cast<CorrectionManager*>( protocol[fromNodeId]->GetManager( PROTOCOL_Correction ) );
		const float origin_x = header.origin_x / float(Resolution);
		const float origin_y = header.origin_y / float(Resolution);
		const float client_x = cubeState.position_x / float(Resolution);
		const float client_y = cubeState.position_y / float(Resolution);
		const float client_dx = origin_x - client_x;
		const float client_dy = origin_y - client_y;
		const float client_d_squared = client_dx*client_dx + client_dy*client_dy;
		if ( client_d_squared < ActivationDistance * ActivationDistance )
		{
			// now check if the server position is outside the activation circle
			// if the client position is inside the circle but the server position is outside
			// then a correction needs to be sent to inform the client of the correct position
			hypercube::DatabaseObject & databaseObject = gameInstance->GetDatabaseObject( cubeState.id );
			math::Vector server_position;
			DecompressPosition( databaseObject.position, server_position );
			const float server_dx = origin_x - server_position.x;
			const float server_dy = origin_y - server_position.y;
			const float server_d_squared = server_dx*server_dx + server_dy*server_dy;
			if ( server_d_squared > ActivationDistance * ActivationDistance )
			{
				math::Quaternion server_orientation;
				DecompressOrientation( databaseObject.orientation, server_orientation );
				correctionManager->AddCorrection( cubeState.id, server_position, server_orientation );
			}
		}
	}
	
	#endif

	void PushState( int fromNodeId, const StateHeader & header, const net::State & state )
	{
		NET_ASSERT( state.GetType() == STATE_Cube || state.GetType() == STATE_Player );
		
		// push player state (input)
		if ( state.GetType() == STATE_Player && IsServer() )
		{
			// NETHACK: todo - we need to have some better validation here for multiple players
			//  - server only accepts input from machine that owns the player cube
			//  - client only accepts input for *other* players from the server (not itself)
			const PlayerState & playerState = static_cast<const PlayerState&>( state );
			int playerId = playerState.id - 1;
			gameInstance->SetPlayerFrame( playerId, playerState.frame );
			gameInstance->SetPlayerInput( playerId, playerState.input );
		}

		// push cube state (position, orientation, velocity etc...)
		const CubeState & cubeState = static_cast<const CubeState&>( state );
		hypercube::ActiveObject * activeObject = gameInstance->FindActiveObject( cubeState.id );
		if ( activeObject )
		{
			// object is active
			if ( ( IsClient() && activeObject->authority == MaxPlayers && cubeState.authority == MaxPlayers ) || 
				#ifndef DISABLE_SESSION_ID
			     ( IsServer() && cubeState.authority == ( fromNodeId - 1 ) && cubeState.session == activeObject->session ) )
				#else
			     ( IsServer() && cubeState.authority == ( fromNodeId - 1 ) ) )
				#endif
			{
				#ifdef DEBUG_PUSH_PULL
				printf( "push active cube %d\n", cubeState.id );
				#endif
				CubeStateToActiveObject( cubeState, *activeObject );
				gameInstance->MoveActiveObject( activeObject, false );
			}

			// client side processing
			if ( IsClient() )
			{
				#ifndef DISABLE_SESSION_ID
				activeObject->session = cubeState.session;
				#endif
				if ( cubeState.authority == MaxPlayers && !cubeState.enabled )
				{
					// client has received server authority object at rest, confirm it
					// at this point we will stop sending network updates for the object
					activeObject->confirmed = 1;
				}
			}
		}
		else
		{
			// if the object is not active on the server then a correction may need to be sent
			#ifndef DISABLE_CORRECTIONS
			if ( IsServer() )
				DetectServerCorrection( header, cubeState, fromNodeId );
			#endif
			
			// if the object is not active on the client, just set its state
			// this indicates that the server knows about some object inside our circle
			// that the client does not know is there
			#ifndef DISABLE_INACTIVE_PUSH
			if ( IsClient() )
			{
				hypercube::DatabaseObject & databaseObject = gameInstance->GetDatabaseObject( cubeState.id );
				float x,y;
				CubeStateToDatabaseObject( cubeState, databaseObject, x, y );
				gameInstance->MoveDatabaseObject( cubeState.id, x, y );
			}
			#endif
		}
	}
	
	void PushObjects( const net::TimeBase & timeBase )
	{
		if ( !IsClient() && !IsServer() )
			return;
		
		// NETHACK: server pushes from node 1, client pushes from node 0
		int fromNodeId = IsServer() ? 1 : 0;
		
		NET_ASSERT( fromNodeId >= 0 );
		NET_ASSERT( fromNodeId < MaxNodes );
		
		// push any received corrections (client only)
		#ifndef DISABLE_CORRECTIONS
		if ( IsClient() )
		{
			CorrectionManager * correctionManager = static_cast<CorrectionManager*>( protocol[fromNodeId]->GetManager( PROTOCOL_Correction ) );
			std::vector<Correction> & receivedCorrections = correctionManager->GetReceivedCorrections();
			for ( int i = 0; i < (int) receivedCorrections.size(); ++i )
				PushCorrection( receivedCorrections[i] );
			correctionManager->ClearReceivedCorrections();
		}
		#endif

		// push most recent objects to simulation
		StateManager * stateManager = static_cast<StateManager*>( protocol[fromNodeId]->GetManager( PROTOCOL_State ) );
		if ( stateManager->IsReadyToReceive() )
		{
			net::State * state[MaxObjectsPerPacket];
			int numObjects = 0;
			net::StateHeader * header = NULL;
			stateManager->Receive( header, state, numObjects );
			NET_ASSERT( header );
			#ifdef DEBUG_PUSH_PULL
			printf( "--------------------------------------\n" );
			printf( "push objects from node %d:\n", fromNodeId );
			#endif
			for ( int i = 0; i < numObjects; ++i )
			{
				PushState( fromNodeId, *static_cast<StateHeader*>(header), *state[i] );
				stateFactory->Destroy( state[i] );
			}
			#ifdef DEBUG_PUSH_PULL
			printf( "--------------------------------------\n" );
			#endif
			stateFactory->DestroyStateHeader( header );
		}
	}

#endif

	void UpdateNetwork( float deltaTime )
	{
		// send packets
		SendPackets( timeBase, deltaTime );
		
		// update transport
		net::Transport::StaticUpdate( timeBase );
		NET_ASSERT( transport );
		transport->Update( timeBase );
		
		// update protocol
		for ( int i = 0; i < MaxNodes; ++i )
			protocol[i]->Update( timeBase );
		
		// detect connection/disconnection
		if ( !connected && transport->IsConnected() )
		{
			printf( "transport connected\n" );
			connected = true;
		}
		else if ( connected && !transport->IsConnected() )
		{
			printf( "transport disconnected\n" );
			connected = false;
		}
		
		// clear received packets from node flag if that node is disconnected
		if ( transport->IsConnected() )
		{
			for ( int i = 0; i < MaxNodes; ++i )
			{
				if ( !transport->IsNodeConnected(i) )
					receivedPacketFromNode[i] = false;
			}
		}
		
		// reset protocol for disconnected nodes
		for ( int i = 0; i < MaxNodes; ++i )
		{
			if ( !transport->IsNodeConnected( i ) )
				protocol[i]->Reset();
		}
		
		// determine which players are joined (if any)
		if ( transport->IsConnected() )
		{
			bool joined[MaxPlayers];
			memset( joined, 0, sizeof( joined ) );
			if ( transport->IsConnected() )
			{
				#ifdef DEBUG_SERVER
				// fake as if player 0 is joined
				joined[0] = true;
				#else
				// players join/leave as nodes [1,5] connect/disconnect (node 0 is dedicated server)
				for ( int i = 0; i < MaxPlayers; ++i )
					joined[i] = transport->IsNodeConnected( i + 1 );
				#endif
			}

			// make game instance knows when players join or leave
			for ( int i = 0; i < MaxPlayers; ++i )
			{
				if ( joined[i] && !gameInstance->IsPlayerJoined( i ) )
				{
					PlayerJoined( i );
				}	
				else if ( !joined[i] && gameInstance->IsPlayerJoined( i ) )
				{
					PlayerLeft( i );
				}
			}
		}
				
		// keep the game instance up to date with the local player id
		int localPlayerId = GetLocalPlayerId();
		if ( localPlayerId != -1 )
			gameInstance->SetLocalPlayer( localPlayerId );

		// receive packets
		ReceivePackets( timeBase );

	#ifndef DISABLE_PUSH_PULL
	
		// process confirmations
		ProcessConfirmations();
	
		// push to sim
		PushObjects( timeBase );
	
	#endif
		
		// advance time base
		timeBase.Advance( deltaTime );
		
		// next logical frame
		frame ++;
	}
	
	void UpdateStats()
	{
		static int accum = 0;
		accum++;
		if ( accum > 60 )
		{
			if ( AnyPlayerJoined() )
			{
				#ifdef DEBUG_SEND_PACKET_BYTES
				printf( "send packet bytes: min = %d, max = %d, avg = %.1f\n", (int) stats.minSendPacketBytes, (int) stats.maxSendPacketBytes, stats.avgSendPacketBytes );
				#endif

				#ifdef DEBUG_RECV_PACKET_BYTES
				printf( "recv packet bytes: min = %d, max = %d, avg = %.1f\n", (int) stats.minRecvPacketBytes, (int) stats.maxRecvPacketBytes, stats.avgRecvPacketBytes );
				#endif
				
				#ifdef DEBUG_CUBE_BYTES
				printf( "cube bytes: min = %.1f, max = %.1f, avg = %.1f\n", 
					stats.minCubeBits / 8.0f, stats.maxCubeBits / 8.0f, stats.avgCubeBits / 8.0f );
				#endif
			}
			accum = 0;
		}
	}	
	
	bool IsServer() const
	{
		return transport->IsConnected() && transport->GetLocalNodeId() == 0;		
	}
	
	bool IsClient() const
	{
		return transport->IsConnected() && transport->GetLocalNodeId() > 0;
	}
	
	int GetLocalPlayerId()
	{
		if ( transport->IsConnected() )
		{
			// NETHACK: make dedicated server think player 0 is local player
			if ( IsServer() )
				return 0;
			return transport->GetLocalNodeId() - 1;
		}
		else
			return -1;
	}
	
	int GetNumJoinedPlayers()
	{
		if ( !transport->IsConnected() )
			return 0;
		#ifdef DEBUG_PUSH_PULL
		return 1;
		#else
		int count = 0;
		for ( int i = 1; i < MaxNodes; ++i )
		{
			if ( transport->IsNodeConnected( i ) )
				count++;
		}
		return count;
		#endif
	}
	
	bool ShouldUpdateSimulation()
	{
		// client updates simulation once local player is joined
		int localPlayerId = GetLocalPlayerId();
		if ( IsClient() && localPlayerId >= 0 )
			return true;
		
		// server updates simulation while any players are joined
		// or while there are still active objects (gives objects a chance to come to rest)
		if ( IsServer() && ( GetNumJoinedPlayers() > 0 || gameInstance->GetNumActiveObjects() > 0 ) )
			return true;
		
		return false;
	}
	
#endif // DISABLE_NETWORKING
};
