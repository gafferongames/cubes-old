/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netProtocol.h"
#include "network/netProtocolManagers.h"

using namespace net;

static const int MaxStateHeaders = 256;

SUITE( NetProtocol )
{
	enum EventTypes
	{
		EVENT_A,
		EVENT_B,
		EVENT_NumTypes
	};
	
	class ProtocolEventA : public Event
	{
	public:
		
		int i,j,k;

		ProtocolEventA() : Event( EVENT_A )
		{
			i = j = k = 0;
		}
	
		bool Serialize( Stream & stream, void * context )
		{
			serialize_uncompressed_int( stream, i );
			serialize_uncompressed_int( stream, j );
			serialize_uncompressed_int( stream, k );
			return true;
		}
		
		bool operator == ( const ProtocolEventA & other ) const
		{
			return i == other.i && j == other.j && k == other.k;
		}
		
		bool operator != ( const ProtocolEventA & other ) const
		{
			return ! ( *this == other );
		}
		
		void Trace( const char channel[] )
		{
			NET_DEBUG( channel, "event A: i=%d, j=%d, k=%d", i, j, k );
		}

		void Print()
		{
			printf( "event A: i=%d, j=%d, k=%d", i, j, k );
		}
	};
	
	class ProtocolEventB : public Event
	{
	public:

		bool i,j,k;
		float x,y,z;
		
		ProtocolEventB() : Event( EVENT_B )
		{
			i = j = k = false;
			x = y = z = 0.0f;
		}

		bool Serialize( Stream & stream, void * context )
		{
			serialize_bool( stream, i );
			serialize_bool( stream, j );
			serialize_bool( stream, k );
			serialize_uncompressed_float( stream, x );
			serialize_uncompressed_float( stream, y );
			serialize_uncompressed_float( stream, z );
			return true;
		}

		bool operator == ( const ProtocolEventB & other ) const
		{
			return i == other.i && j == other.j && k == other.k &&
				   x == other.x && y == other.y && z == other.z;
		}

		bool operator != ( const ProtocolEventB & other ) const
		{
			return ! ( *this == other );
		}
		
		void Trace( const char channel[] )
		{
			NET_DEBUG( channel, "event B: i=%d, j=%d, k=%d, x=%1f, y=%1f, z=%1f", i, j, k, x, y, z );
		}
		
		void Print()
		{
			printf( "event B: i=%d, j=%d, k=%d, x=%1f, y=%1f, z=%1f\n", i, j, k, x, y, z );
		}
	};
	
	class TestProtocolEventFactory : public AtomFactory
	{
	public:		

		int GetNumTypes() const
		{
			return EVENT_NumTypes;
		}
		
		const char * GetTypeName( int type ) const
		{
			if ( type == EVENT_A )
				return "a";
			else if ( type == EVENT_B )
				return "b";
			else
				return "???";
		}

        void Construct( int type, void * block )
        {
			if ( type == EVENT_A )
			{
				NET_ASSERT( sizeof( ProtocolEventA ) <= (size_t) GetConfig().maxAtomSize );
				new(block) ProtocolEventA();
			}
			else if ( type == EVENT_B )
			{
				NET_ASSERT( sizeof( ProtocolEventB ) <= (size_t) GetConfig().maxAtomSize );
				new(block) ProtocolEventB();
			}
        }
	};
	
	// -------------------------------------------------------------------------------

	enum StateTypes
	{
		STATE_A,
		STATE_B,
		STATE_NumTypes
	};

	struct ProtocolState : public net::State
	{	 
	public:
		ProtocolState( int _type ) : net::State(_type), id(0) {}
		void SetId( uint32_t _id ) { id = _id; }
		uint32_t GetId() const { return id; }
		uint32_t id;
	};

	class ProtocolStateA : public ProtocolState
	{
	public:
		
		int i,j,k;
		bool optional;
		int optional_a;
		int optional_b;
		int optional_c;

		ProtocolStateA() : ProtocolState( STATE_A )
		{
			i = j = k = 0;
			optional = false;
			optional_a = 0;
			optional_b = 0;
			optional_c = 0;
		}
			
		bool Serialize( Stream & stream, void * context )
		{
			serialize_uncompressed_int( stream, id );
			serialize_uncompressed_int( stream, i );
			serialize_uncompressed_int( stream, j );
			serialize_uncompressed_int( stream, k );
			serialize_bool( stream, optional );
			if ( optional )
			{
				serialize_uncompressed_int( stream, optional_a );
				serialize_uncompressed_int( stream, optional_b );
				serialize_uncompressed_int( stream, optional_c );
			}
			return true;
		}
		
		bool operator == ( const ProtocolStateA & other ) const
		{
			return i == other.i && j == other.j && k == other.k && optional == other.optional && 
				( !optional || ( optional && ( optional_a == other.optional_a && optional_b == other.optional_b && optional_c == other.optional_c ) ) );
		}
		
		bool operator != ( const ProtocolStateA & other ) const
		{
			return ! ( *this == other );
		}

        void Trace( const char channel[] )
        {
        }

		void Print()
		{
			printf( "state A: i=%d, j=%d, k=%d\n", i, j, k );
		}
	};
	
	class ProtocolStateB : public ProtocolState
	{
	public:

		bool i,j,k;
		float x,y,z;
		
		ProtocolStateB() : ProtocolState( STATE_B )
		{
			id = 0;
			i = j = k = false;
			x = y = z = 0.0f;
		}
		
		bool Serialize( Stream & stream, void * context )
		{
			serialize_uncompressed_int( stream, id );
			serialize_bool( stream, i );
			serialize_bool( stream, j );
			serialize_bool( stream, k );
			serialize_uncompressed_float( stream, x );
			serialize_uncompressed_float( stream, y );
			serialize_uncompressed_float( stream, z );
			return true;
		}

		bool operator == ( const ProtocolStateB & other ) const
		{
			return i == other.i && j == other.j && k == other.k &&
				   x == other.x && y == other.y && z == other.z;
		}

		bool operator != ( const ProtocolStateB & other ) const
		{
			return ! ( *this == other );
		}
		
		void Trace( const char channel[] )
		{
		}

        void Print()
        {
			printf( "state B: i=%d, j=%d, k=%d, x=%1f, y=%1f, z=%1f\n", i, j, k, x, y, z );
        }
	};
	
	class TestProtocolStateHeader : public net::StateHeader
	{
	public:
		
		uint32_t frame;

		TestProtocolStateHeader()
		{
			frame = 0;
		}
		
		bool Serialize( net::Stream & stream )
		{
			serialize_uncompressed_int( stream, frame );
			return true;
		}	
	};
	
	class TestProtocolStateFactory : public net::StateFactory
	{
	public:

		TestProtocolStateFactory() : net::StateFactory( AtomFactoryConfig() )
		{
			m_headerPool = new PoolAllocator( MaxStateHeaders, sizeof( TestProtocolStateHeader ) );
		}
		
		~TestProtocolStateFactory()
		{
			delete m_headerPool;
			m_headerPool = NULL;
		}
		
		int GetNumTypes() const
		{
			return STATE_NumTypes;
		}
		
		const char * GetTypeName( int type ) const
		{
			if ( type == STATE_A )
				return "a";
			else if ( type == STATE_B )
				return "b";
			else
				return "???";
		}

        void Construct( int type, void * block )
        {
			if ( type == STATE_A )
			{
				NET_ASSERT( sizeof( ProtocolStateA ) <= (size_t) GetConfig().maxAtomSize );
				new(block) ProtocolStateA();
			}
			else if ( type == STATE_B )
			{
				NET_ASSERT( sizeof( ProtocolStateB ) <= (size_t) GetConfig().maxAtomSize );
				new(block) ProtocolStateB();
			}
        }

		net::StateHeader * CreateStateHeader()
		{
			uint8_t * block = (uint8_t*) m_headerPool->Allocate();
			NET_ASSERT( block );
			new(block) TestProtocolStateHeader();
			return (net::StateHeader*) block;
		}

		void DestroyStateHeader( net::StateHeader * header )
		{
			NET_ASSERT( header );
			header->~StateHeader();
			m_headerPool->Free( header );
		}

	private:

		PoolAllocator * m_headerPool;
	};
	
	// -------------------------------------------------------------------------------

	class TestProtocolChunkConfig : public ChunkConfig
	{
	public:
		
		TestProtocolChunkConfig()
		{
			strcpy( channelConfigs[0].name, "A" );
			strcpy( channelConfigs[1].name, "B" );
			strcpy( channelConfigs[2].name, "C" );
		}
	
		const ChunkChannelConfig * GetChunkChannelConfigs( int & numChannels ) const
		{
			numChannels = 3;
			return channelConfigs;
		}
		
		ChunkChannelConfig channelConfigs[3];
	};
	
	// -------------------------------------------------------------------------------

	TEST( test_protocol_add_managers )
	{
		ProtocolConfig config;
		Protocol protocol( config );
		
		CHECK( !protocol.IsLocked() );
		CHECK( protocol.GetNumManagers() == 0 );
	
		TestProtocolEventFactory eventFactory;
		TestProtocolStateFactory stateFactory;
		
		ReliabilityManager * reliabilityManager = new ReliabilityManager();
		EventManager * eventManager = new EventManager( eventFactory );
		ChunkManager * chunkManager = new ChunkManager();
		StateManager * stateManager = new StateManager( stateFactory );
		
		protocol.AddManager( reliabilityManager );
		protocol.AddManager( eventManager );
		protocol.AddManager( chunkManager );
		protocol.AddManager( stateManager );
		
		protocol.Lock();
		
		CHECK( protocol.IsLocked() );
		CHECK( protocol.GetNumManagers() == 4 );
		CHECK( protocol.GetManager(0) == reliabilityManager );
		CHECK( protocol.GetManager(1) == eventManager );
		CHECK( protocol.GetManager(2) == chunkManager );
		CHECK( protocol.GetManager(3) == stateManager );
	}
	
	TEST( test_protocol_write_packet )
	{
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
		TestProtocolEventFactory eventFactory;
		TestProtocolStateFactory stateFactory;
		
		ProtocolConfig config;
		Protocol protocol( config );
		
		ReliabilityManager * reliabilityManager = new ReliabilityManager();
		EventManager * eventManager = new EventManager( eventFactory );
		ChunkManager * chunkManager = new ChunkManager();
		StateManager * stateManager = new StateManager( stateFactory );
		
		protocol.AddManager( reliabilityManager );
		protocol.AddManager( eventManager );
		protocol.AddManager( chunkManager );
		protocol.AddManager( stateManager );
		
		protocol.Lock();

        net::TimeBase timeBase;
		uint8_t packet_data[MaxPacketBytes];
		int packet_bytes = MaxPacketBytes;
		CHECK( protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
		CHECK( packet_bytes > 0 );
		CHECK( packet_bytes < MaxPacketBytes );
	}
	
	TEST( test_protocol_write_read_packet )
	{
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
		TestProtocolEventFactory eventFactory;
		TestProtocolStateFactory stateFactory;
		
		ProtocolConfig config;
		Protocol write_protocol( config );
		Protocol read_protocol( config );
		
		write_protocol.AddManager( new ReliabilityManager() );
		write_protocol.AddManager( new EventManager( eventFactory ) );
		write_protocol.AddManager( new ChunkManager() );
		write_protocol.AddManager( new StateManager( stateFactory ) );

		read_protocol.AddManager( new ReliabilityManager() );
		read_protocol.AddManager( new EventManager( eventFactory ) );
		read_protocol.AddManager( new ChunkManager() );
		read_protocol.AddManager( new StateManager( stateFactory ) );

		write_protocol.Lock();
		read_protocol.Lock();

        net::TimeBase timeBase;

        uint8_t packet_data[MaxPacketBytes];
		int packet_bytes = MaxPacketBytes;
		CHECK( write_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
		CHECK( packet_bytes > 0 );
		CHECK( packet_bytes < MaxPacketBytes );
		
		CHECK( read_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
	}

	TEST( test_protocol_write_read_packet_no_checks_no_journal )
	{
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
		TestProtocolEventFactory eventFactory;
		TestProtocolStateFactory stateFactory;
		
		ProtocolConfig config;
		config.checks = false;
		config.journal = false;
		
		Protocol write_protocol( config );
		Protocol read_protocol( config );
		
		write_protocol.AddManager( new ReliabilityManager() );
		write_protocol.AddManager( new EventManager( eventFactory ) );
		write_protocol.AddManager( new ChunkManager() );
		write_protocol.AddManager( new StateManager( stateFactory ) );

		read_protocol.AddManager( new ReliabilityManager() );
		read_protocol.AddManager( new EventManager( eventFactory ) );
		read_protocol.AddManager( new ChunkManager() );
		read_protocol.AddManager( new StateManager( stateFactory ) );

		write_protocol.Lock();
		read_protocol.Lock();

        net::TimeBase timeBase;

		uint8_t packet_data[MaxPacketBytes];
		int packet_bytes = MaxPacketBytes;
		CHECK( write_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
		CHECK( packet_bytes > 0 );
		CHECK( packet_bytes < MaxPacketBytes );
		
		CHECK( read_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
	}
	
	TEST( test_protocol_events )
	{
		const float DeltaTime = 0.1f;
		const int NumEvents = 256;
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestProtocolEventFactory eventFactory;
		TestProtocolStateFactory stateFactory;
		
		struct EventData
		{
			Event * event;
			int eventType;
			ProtocolEventA a_copy;			// hack: need copy because the sent event is deleted on ack
			ProtocolEventB b_copy;
		};
		
		EventData eventData[NumEvents];
		for ( int i = 0; i < NumEvents; ++i )
		{
			if ( rand() % 2 )
			{
				ProtocolEventA * a = static_cast<ProtocolEventA*>( eventFactory.Create( EVENT_A ) );
				NET_ASSERT( a );
				a->i = rand() % 1000;
				a->j = rand() % 1000;
				a->k = rand() % 1000;
				eventData[i].event = a;
				eventData[i].eventType = EVENT_A;
				eventData[i].a_copy = *a;
			}
			else
			{
				ProtocolEventB * b = static_cast<ProtocolEventB*>( eventFactory.Create( EVENT_B ) );
				NET_ASSERT( b );
				b->i = ( rand() % 2 ) ? true : false;
				b->j = ( rand() % 2 ) ? true : false;
				b->k = ( rand() % 2 ) ? true : false;
				b->x = float( rand() % 1000 );
				b->y = float( rand() % 1000 );
				b->z = float( rand() % 1000 );
				eventData[i].event = b;
				eventData[i].eventType = EVENT_B;
				eventData[i].b_copy = *b;
			}
		}

		ProtocolConfig config;
		config.checks = true;
		config.journal = true;
		
		Protocol write_protocol( config );
		Protocol read_protocol( config );
		
		write_protocol.AddManager( new ReliabilityManager() );
		write_protocol.AddManager( new EventManager( eventFactory ) );

		read_protocol.AddManager( new ReliabilityManager() );
		read_protocol.AddManager( new EventManager( eventFactory ) );

		write_protocol.Lock();
		read_protocol.Lock();
		
		// ------------------------------------------------------------------------------

		int eventsSent = 0;
		int eventsReceived = 0;

		EventManager * sendEventManager = static_cast<EventManager*>( write_protocol.GetManager( 1 ) );
		EventManager * receiveEventManager = static_cast<EventManager*>( read_protocol.GetManager( 1 ) );

		while ( eventsReceived < NumEvents )
		{
			write_protocol.Update( timeBase );
			read_protocol.Update( timeBase );
			
			while ( sendEventManager->CanSend() && eventsSent < NumEvents )
			{
				CHECK( sendEventManager->Send( eventData[eventsSent].event ) );
				eventData[eventsSent].event = NULL;
				eventsSent++;
			}

			{
				// write -> read
				uint8_t packet_data[MaxPacketBytes];
				int packet_bytes = MaxPacketBytes;
				CHECK( write_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
				CHECK( packet_bytes > 0 );
				CHECK( packet_bytes < MaxPacketBytes );
				if ( ( rand() % 2 ) == 0 )
					CHECK( read_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			}
			
			{
				// read -> write (necessary for acks to function)
				uint8_t packet_data[MaxPacketBytes];
				int packet_bytes = MaxPacketBytes;
				CHECK( read_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
				CHECK( packet_bytes > 0 );
				CHECK( packet_bytes < MaxPacketBytes );
				if ( ( rand() % 2 ) == 0 )
					CHECK( write_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			}

			while ( Event * event = receiveEventManager->Receive() )
			{
				CHECK( eventData[eventsReceived].eventType == event->GetType() );
				if ( event->GetType() == EVENT_A )
				{
					ProtocolEventA * a = static_cast<ProtocolEventA*>( event );
					CHECK( *a == eventData[eventsReceived].a_copy );
					if ( *a != eventData[eventsReceived].a_copy )
					{
						static_cast<ProtocolEventA*>(event)->Print();
						eventData[eventsReceived].a_copy.Print();
						printf( "error: invalid event a\n" );
						exit(1);
					}
				}
				else
				{
					ProtocolEventB * b = static_cast<ProtocolEventB*>( event );
					CHECK( *b == eventData[eventsReceived].b_copy );
					if ( *b != eventData[eventsReceived].b_copy )
					{
						static_cast<ProtocolEventB*>(event)->Print();
						eventData[eventsReceived].b_copy.Print();
						printf( "error: invalid event b\n" );
						exit(1);
					}
				}
				eventFactory.Destroy( event );
				eventsReceived++;
			}

            timeBase.time += timeBase.deltaTime;
		}
		
		// make sure the event queue is cleaned up before factory dtor
		
		read_protocol.Reset();
		write_protocol.Reset();
	}
	
	TEST( test_protocol_chunks )
	{
		const float DeltaTime = 0.1f;
		const int ChannelId = 0;
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		ProtocolConfig config;
		config.checks = true;
		config.journal = true;
		
		Protocol write_protocol( config );
		Protocol read_protocol( config );
		
		TestProtocolChunkConfig chunkConfig;

		write_protocol.AddManager( new ReliabilityManager() );
		write_protocol.AddManager( new ChunkManager( chunkConfig ) );

		read_protocol.AddManager( new ReliabilityManager() );
		read_protocol.AddManager( new ChunkManager( chunkConfig ) );

		write_protocol.Lock();
		read_protocol.Lock();
		
		// ------------------------------------------------------------------------------

		uint8_t send_chunk[1000];
 		uint8_t recv_chunk[1000];
		memset( recv_chunk, 0, sizeof(recv_chunk) );
		for ( int i = 0; i < (int) sizeof(send_chunk); ++i )
			send_chunk[i] = (uint8_t) ( rand() % 256 );

		ChunkManager * sendChunkManager = static_cast<ChunkManager*>( write_protocol.GetManager( 1 ) );
		ChunkManager * receiveChunkManager = static_cast<ChunkManager*>( read_protocol.GetManager( 1 ) );

		sendChunkManager->Send( ChannelId, send_chunk, sizeof( send_chunk ) );

		while ( !sendChunkManager->SendCompleted( ChannelId ) || !receiveChunkManager->ReceiveCompleted( ChannelId ) )
		{
			write_protocol.Update( timeBase );
			read_protocol.Update( timeBase );
			
			{
				// write -> read
				uint8_t packet_data[MaxPacketBytes];
				int packet_bytes = MaxPacketBytes;
				CHECK( write_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
				CHECK( packet_bytes > 0 );
				CHECK( packet_bytes < MaxPacketBytes );
				if ( ( rand() % 10 ) == 0 )
					CHECK( read_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			}
			
			{
				// read -> write (necessary for acks to function)
				uint8_t packet_data[MaxPacketBytes];
				int packet_bytes = MaxPacketBytes;
				CHECK( read_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
				CHECK( packet_bytes > 0 );
				CHECK( packet_bytes < MaxPacketBytes );
				if ( ( rand() % 10 ) == 0 )
					CHECK( write_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			}

            timeBase.time += timeBase.deltaTime;
		}
		
		CHECK( !sendChunkManager->IsSending( ChannelId ) );
		CHECK( sendChunkManager->SendCompleted( ChannelId ) );
		CHECK_CLOSE( sendChunkManager->GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );

		CHECK( receiveChunkManager->IsReceiving( ChannelId ) );
		CHECK( receiveChunkManager->ReceiveCompleted( ChannelId ) );

		int bytes = sizeof(recv_chunk);
		CHECK( receiveChunkManager->Receive( ChannelId, recv_chunk, bytes ) );
		CHECK( bytes == sizeof(recv_chunk) );
		CHECK( memcmp( recv_chunk, send_chunk, sizeof(recv_chunk) ) == 0 );

		CHECK( !receiveChunkManager->IsReceiving( ChannelId ) );
		CHECK( receiveChunkManager->ReceiveCompleted( ChannelId ) );
	}
	
	TEST( test_protocol_state )
	{
		const float DeltaTime = 0.1f;
		const int MaxPacketBytes = 2048;
		const int MaxDataBytes = 1024;
		const int MaxJournalBytes = 512;
		
        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

        ProtocolConfig config;
		config.checks = true;
		config.journal = true;
		
		Protocol write_protocol( config );
		Protocol read_protocol( config );
		
		TestProtocolChunkConfig chunkConfig;
		
		TestProtocolStateFactory factory;

		write_protocol.AddManager( new ReliabilityManager() );
		write_protocol.AddManager( new StateManager( factory ) );

		read_protocol.AddManager( new ReliabilityManager() );
		read_protocol.AddManager( new StateManager( factory ) );

		write_protocol.Lock();
		read_protocol.Lock();
		
		// ------------------------------------------------------------------------------

		const int MaxObjectsPerPacket = 32;

		StateConfig stateConfig;
		stateConfig.maxObjectsPerPacket = MaxObjectsPerPacket;

		net::State * sendStateObjects[MaxObjectsPerPacket];

		for ( int i = 0; i < MaxObjectsPerPacket; ++i )
		{
			if ( rand() % 2 )
			{
				ProtocolStateA * a = static_cast<ProtocolStateA*>( factory.Create( STATE_A ) );
				NET_ASSERT( a );
				a->SetId( i );
				a->i = rand() % 1000;
				a->j = rand() % 1000;
				a->k = rand() % 1000;
				a->optional = ( rand() % 2 ) ? true : false;
				a->optional_a = rand() % 1000;
				a->optional_b = rand() % 1000;
				a->optional_c = rand() % 1000;
				sendStateObjects[i] = a;
			}
			else
			{
				ProtocolStateB * b = static_cast<ProtocolStateB*>( factory.Create( STATE_B ) );
				NET_ASSERT( b );
				b->SetId( i );
				b->i = ( rand() % 2 ) ? true : false;
				b->j = ( rand() % 2 ) ? true : false;
				b->k = ( rand() % 2 ) ? true : false;
				b->x = float( rand() % 1000 );
				b->y = float( rand() % 1000 );
				b->z = float( rand() % 1000 );
				sendStateObjects[i] = b;
			}
		}

		// -------------------------------------------------------------------------

		StateManager * sendStateManager = static_cast<StateManager*>( write_protocol.GetManager( 1 ) );
		StateManager * receiveStateManager = static_cast<StateManager*>( read_protocol.GetManager( 1 ) );

		// note: clone objects to send, so we can compare sent objects to those received (objects are deleted on send)
		{
			net::State * clonedObjects[MaxObjectsPerPacket];
			for ( int i = 0; i < MaxObjectsPerPacket; ++i )
			{
				clonedObjects[i] = (State*) factory.Clone( sendStateObjects[i] );
				CHECK( clonedObjects[i] );
			}

			TestProtocolStateHeader * stateHeader = static_cast<TestProtocolStateHeader*>( factory.CreateStateHeader() );
			NET_ASSERT( stateHeader );
			stateHeader->frame = 100;

			sendStateManager->Send( stateHeader, clonedObjects, stateConfig.maxObjectsPerPacket );
		}

		write_protocol.Update( timeBase );
		read_protocol.Update( timeBase );
		
		{
			// write -> read
			uint8_t packet_data[MaxPacketBytes];
			int packet_bytes = MaxPacketBytes;
			CHECK( write_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			CHECK( packet_bytes > 0 );
			CHECK( packet_bytes < MaxPacketBytes );
			CHECK( read_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
		}
		
		{
			// read -> write (necessary for acks to function)
			uint8_t packet_data[MaxPacketBytes];
			int packet_bytes = MaxPacketBytes;
			CHECK( read_protocol.WritePacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
			CHECK( packet_bytes > 0 );
			CHECK( packet_bytes < MaxPacketBytes );
			CHECK( write_protocol.ReadPacket( timeBase, packet_data, packet_bytes, MaxDataBytes, MaxJournalBytes ) );
		}
		
		CHECK( receiveStateManager->IsReadyToReceive() );

		net::State * receiveStateObjects[MaxObjectsPerPacket];
		
		int receiveNumObjects = 0;
		net::StateHeader * header = NULL;
		receiveStateManager->Receive( header, receiveStateObjects, receiveNumObjects );
		
		CHECK( header );
		CHECK( ((TestProtocolStateHeader*)header)->frame == 100 );
		CHECK( receiveNumObjects == stateConfig.maxObjectsPerPacket );

		factory.DestroyStateHeader( header );

		for ( int i = 0; i < receiveNumObjects; ++i )
		{
			CHECK( receiveStateObjects[i] );
			CHECK( receiveStateObjects[i]->GetType() == sendStateObjects[i]->GetType() );
			if ( receiveStateObjects[i]->GetType() == STATE_A )
			{
				ProtocolStateA * a_sent = static_cast<ProtocolStateA*>( sendStateObjects[i] );
				ProtocolStateA * a_recv = static_cast<ProtocolStateA*>( receiveStateObjects[i] );
				CHECK( *a_sent == *a_recv );
			}
			else
			{
				ProtocolStateB * b_sent = static_cast<ProtocolStateB*>( sendStateObjects[i] );
				ProtocolStateB * b_recv = static_cast<ProtocolStateB*>( receiveStateObjects[i] );
				CHECK( *b_sent == *b_recv );
			}
		}

		for ( int i = 0; i < receiveNumObjects; ++i )
			factory.Destroy( receiveStateObjects[i] );

		for ( int i = 0; i < MaxObjectsPerPacket; ++i )
			factory.Destroy( sendStateObjects[i] );

		// clean up objects before factory disappears
		read_protocol.Reset();
		write_protocol.Reset();
	}
}
