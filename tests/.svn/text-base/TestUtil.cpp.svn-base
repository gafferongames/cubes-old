/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netUtil.h"

struct TestUtilEvent
{
    int exists;
	int data;
};

using namespace net;

SUITE( NetUtil )
{
    TEST( test_util_hash )
	{
		char a[] = "hello my baby";
		char b[] = "hello my ragtime doll";
		CHECK( hash( (uint8_t*)a, 10 ) != hash( (uint8_t*)b, 10 ) );
		CHECK( hash_string( a ) != hash_string( b ) );
	}

	TEST( test_util_sequence_more_recent )
	{
		CHECK( sequence_more_recent( 0, 1, 65535 ) );
		CHECK( sequence_more_recent( 1, 2, 65535 ) );
		CHECK( sequence_more_recent( 2, 3, 65535 ) );
		CHECK( sequence_more_recent( 65535, 0, 65535 ) );
		CHECK( sequence_more_recent( 65500, 100, 65535 ) );
		CHECK( !sequence_more_recent( 0, 65535, 65535 ) );
		CHECK( !sequence_more_recent( 65535, 32768, 65535 ) );
	}

	TEST( test_util_sliding_window )
	{
		// add events

		const int Size = 256;

		SlidingWindow<TestUtilEvent> slidingWindow( Size );

		for ( int i = 0; i < Size; ++i )
		{
			CHECK( slidingWindow.GetCount() == i );
			TestUtilEvent * event = slidingWindow.Add( i );
			CHECK( slidingWindow.GetCount() == i + 1 );
			CHECK( event );
			event->data = i;
		}

		// test get event inside window

		for ( int i = 0; i < Size; ++i )
		{
			TestUtilEvent * event = slidingWindow.Get( i );
			CHECK( event != NULL );
			CHECK( event->data == i );
		}

		// test get event outside window

		for ( int i = Size; i < 65535; ++i )
		{
			TestUtilEvent * event = slidingWindow.Get( i );
			CHECK( event == NULL );
		}

		// test advance

		for ( int i = 1; i <= Size; ++i )
		{
			CHECK( slidingWindow.GetCount() == Size - i + 1 );
			CHECK( slidingWindow.GetMinimumId() == i - 1 );
			CHECK( slidingWindow.GetMaximumId() == i - 1 + Size - 1 );
			slidingWindow.Advance( i );
			CHECK( slidingWindow.GetCount() == Size - i );
			CHECK( slidingWindow.GetMinimumId() == i );
			CHECK( slidingWindow.GetMaximumId() == i + Size - 1 );
			for ( int j = 0; j < i; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( j );
				CHECK( event == NULL );
			}
			for ( int j = i; j < Size; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( j );
				CHECK( event );
				CHECK( event->data == j );
			}
			for ( int j = Size; j < Size * 2; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( j );
				CHECK( event == NULL );
			}
		}

		// test clear

		slidingWindow.Clear();
		CHECK( slidingWindow.GetMinimumId() == 0 );

		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) == NULL );
		for ( int i = 0; i < Size; ++i )
			slidingWindow.Add( i );
		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) );

		slidingWindow.Clear();
		CHECK( slidingWindow.GetMinimumId() == 0 );
		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) == NULL );

		// test advance large step

		CHECK( slidingWindow.GetCount() == 0 );

		for ( int i = 0; i < 256; ++i )
			slidingWindow.Add( i );

		CHECK( slidingWindow.GetCount() == 256 );

		slidingWindow.Advance( 1000 );

		CHECK( slidingWindow.GetCount() == 0 );

		for ( int i = 0; i < 256; ++i )
			CHECK( slidingWindow.Get( i ) == NULL );

		// test set/get

		slidingWindow.Clear();

		for ( int i = 0; i < 256; i += 2 )
			slidingWindow.Add( i );

		for ( int i = 0; i < 256; ++i )
		{
			if ( ( i & 1 ) == 0 )
				CHECK( slidingWindow.Get( i ) );
			else
				CHECK( slidingWindow.Get( i ) == NULL );
		}

		// test wrap around

		slidingWindow.Clear();

		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) == NULL );
		for ( int i = 0; i < Size; ++i )
			slidingWindow.Add( i );
		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) );

		CHECK( slidingWindow.GetCount() == Size );
		CHECK( slidingWindow.GetMinimumId() == 0 );

		const int base = 65500;
		slidingWindow.Rebase( base );

		CHECK( slidingWindow.GetCount() == 0 );
		CHECK( slidingWindow.GetMinimumId() == base );

		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( i ) == NULL );

		for ( int i = 0; i < Size; ++i )
		{
			TestUtilEvent * event = slidingWindow.Add( uint16_t( i + base ) );
			CHECK( event );
			event->data = i;
		}

		for ( int i = 0; i < Size; ++i )
			CHECK( slidingWindow.Get( uint16_t( i + base ) ) != NULL );

		// test advance with wrap-around

		for ( int i = 1; i <= Size; ++i )
		{
			CHECK( slidingWindow.GetCount() == Size - i + 1 );
			CHECK( slidingWindow.GetMinimumId() == uint16_t( base + i - 1 ) );
			CHECK( slidingWindow.GetMaximumId() == uint16_t( base + i - 1 + Size - 1 ) );
			slidingWindow.Advance( base + i );
			CHECK( slidingWindow.GetCount() == Size - i );
			CHECK( slidingWindow.GetMinimumId() == uint16_t( base + i ) );
			CHECK( slidingWindow.GetMaximumId() == uint16_t( base + i + Size - 1 ) );
			for ( int j = 0; j < i; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( uint16_t( base + j ) );
				CHECK( event == NULL );
			}
			for ( int j = i; j < Size; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( uint16_t( base + j ) );
				CHECK( event );
				CHECK( event->data == j );
			}
			for ( int j = Size; j < Size * 2; ++j )
			{
				TestUtilEvent * event = slidingWindow.Get( uint16_t( base + j ) );
				CHECK( event == NULL );
			}
		}
	}

	TEST( test_util_packet_stack )
	{
		// create packet stack

		const int size = 1024;
		uint32_t memory[size/4];
		PacketStack packetStack( (uint8_t*)memory, size );
		memset( memory, 0, sizeof(memory) );
		
		// push packet

		for ( int i = 0; i < 10; ++i )
		{
			int nodeId = i;
			int packetSize = 20 + i;
			uint8_t packet[256];
			for ( int j = 0; j < packetSize; ++j )
				packet[j] = (uint8_t) ( j + i );
			CHECK( packetStack.GetPacketCount() == i );
			CHECK( packetStack.PushPacket( nodeId, packet, packetSize ) );
			CHECK( packetStack.GetPacketCount() == i + 1 );
		}

		// pop packet

		for ( int i = 9; i >= 0; --i )
		{
			int nodeId = 0;
			int packetSize = 0;
			uint8_t * packet = NULL;
			CHECK( packetStack.GetPacketCount() == i + 1 );
			CHECK( packetStack.PopPacket( &nodeId, &packet, &packetSize ) );
			CHECK( nodeId == i );
			CHECK( packetSize == 20 + i );
			CHECK( packetStack.GetPacketCount() == i );
			for ( int j = 0; j < packetSize; ++j )
			{
				CHECK( packet[j] == (uint8_t) ( j + i ) );
			}
		}

		// clear

		for ( int i = 0; i < 10; ++i )
		{
			int nodeId = i;
			int packetSize = 20 + i;
			uint8_t packet[256];
			for ( int j = 0; j < packetSize; ++j )
				packet[j] = (uint8_t) ( j + i );
			CHECK( packetStack.GetPacketCount() == i );
			CHECK( packetStack.PushPacket( nodeId, packet, packetSize ) );
			CHECK( packetStack.GetPacketCount() == i + 1 );
		}

		packetStack.Clear();

		CHECK( packetStack.GetPacketCount() == 0 );

		// full

		for( int i = 0; i < 10; ++i )
		{
			int nodeId = i;
			int packetSize = 256;
			uint8_t packet[256];
			for ( int j = 0; j < packetSize; ++j )
				packet[j] = (uint8_t) ( j + i );
			CHECK( packetStack.GetPacketCount() == ( ( i < 3 ) ? i : 3 ) );
			bool result = packetStack.PushPacket( nodeId, packet, packetSize );
			CHECK( ( i < 3 && result ) || ( i >= 3 && !result ) );
			if ( result )
				CHECK( packetStack.GetPacketCount() == ( ( ( i + 1 < 3 ) ? ( i + 1 ) : 3 ) ) );
		}

		CHECK( packetStack.GetPacketCount() == 3 );

		// read all packets until empty, verify it clears out count to zero

		while ( packetStack.GetPacketCount() > 0 )
		{
			int nodeId = 0;
			int packetSize = 0;
			uint8_t * packet = NULL;
			CHECK( packetStack.PopPacket( &nodeId, &packet, &packetSize ) );
		}

		CHECK( packetStack.GetPacketCount() == 0 );

		// test push/pop in rapid succession (odd)

		for ( int i = 0; i < 1000; ++i )
		{
			{
				int nodeId = i;
				int packetSize = 23;
				uint8_t packet[23];
				for ( int j = 0; j < packetSize; ++j )
					packet[j] = (uint8_t) ( j + i );
				CHECK( packetStack.GetPacketCount() == 0 );
				CHECK( packetStack.PushPacket( nodeId, packet, packetSize ) );
				CHECK( packetStack.GetPacketCount() == 1 );
			}

			{
				int nodeId = 0;
				int packetSize = 0;
				uint8_t * packet = NULL;
				CHECK( packetStack.GetPacketCount() == 1 );
				CHECK( packetStack.PopPacket( &nodeId, &packet, &packetSize ) );
				CHECK( nodeId == i );
				CHECK( packetSize == 23 );
				CHECK( packetStack.GetPacketCount() == 0 );
				for ( int j = 0; j < packetSize; ++j )
				{
					CHECK( packet[j] == (uint8_t) ( j + i ) );
				}
			}
		}
	}
		
	TEST( test_block_allocator )
	{
		const int MemSize = 1024;
		const int MaxBlocks = 21;
		
		BlockAllocator blockAllocator( MemSize, MaxBlocks );
		
		// first allocate a whole load of blocks
		
		int used = 0;
		int blockSizes[MaxBlocks];
		
		for ( int i = 0; i < MaxBlocks; ++i )
		{
			blockSizes[i] = rand() % 50 + 10;
			used += blockSizes[i];
			int blockId = blockAllocator.AllocateBlock( blockSizes[i] );
			CHECK( blockId == i );
			CHECK( blockAllocator.GetBlockSize( i ) == blockSizes[i] );
			uint8_t * ptr = blockAllocator.GetBlockPtr( i );
			CHECK( ptr );
			for ( int j = 0; j < blockSizes[i]; ++j )
				ptr[j] = i;
		}
		
		CHECK( blockAllocator.GetUsedBytes() == used );
		CHECK( blockAllocator.GetFreeBytes() == MemSize - used );
		CHECK( blockAllocator.GetTotalBytes() == MemSize );
		
		// now delete a few random ones at the front, in the middle and at the end
		// and verify that all the other blocks are still cool (even though they have moved)
		
		used -= blockSizes[0] + blockSizes[10] + blockSizes[MaxBlocks-1];

		blockAllocator.FreeBlock( 0 );
		blockAllocator.FreeBlock( 10 );
		blockAllocator.FreeBlock( MaxBlocks - 1 );
		
		blockSizes[0] = blockSizes[10] = blockSizes[MaxBlocks-1] = 0;
		
		CHECK( blockAllocator.GetUsedBytes() == used );
		CHECK( blockAllocator.GetFreeBytes() == MemSize - used );
		CHECK( blockAllocator.GetTotalBytes() == MemSize );

		for ( int i = 0; i < MaxBlocks; ++i )
		{
			if ( blockSizes[i] )
			{
				uint8_t * ptr = blockAllocator.GetBlockPtr( i );
				CHECK( ptr );
				for ( int j = 0; j < blockSizes[i]; ++j )
					CHECK( ptr[j] == i );
			}
		}
		
		// now verify we can alloc three more blocks, and everything is cool
				
		for ( int i = 0; i < 3; ++i )
		{
			blockSizes[i] = rand() % 50 + 10;
			int blockId = blockAllocator.AllocateBlock( blockSizes[i] );
			CHECK( blockId != -1 );
			uint8_t * ptr = blockAllocator.GetBlockPtr( blockId );
			CHECK( ptr );
			for ( int j = 0; j < blockSizes[i]; ++j )
				ptr[j] = i;
		}
		
		// now free all blocks
		
		for ( int i = 0; i < MaxBlocks; ++i )
			blockAllocator.FreeBlock( i );
			
		CHECK( blockAllocator.GetUsedBytes() == 0 );
		CHECK( blockAllocator.GetFreeBytes() == MemSize );
		CHECK( blockAllocator.GetTotalBytes() == MemSize );
	}

	TEST( test_util_pool_allocator )
	{
		const int MemSize = 1024;
		const int BlockSize = 32;
		const int NumBlocks = MemSize / BlockSize;
		
		PoolAllocator poolAllocator( MemSize, BlockSize );
		
		uint8_t * ptrs[NumBlocks];
		
		for ( int i = 0; i < NumBlocks; ++i )
		{
			ptrs[i] = (uint8_t*) poolAllocator.Allocate();
			CHECK( ptrs[i] );
			memset( ptrs[i], (uint8_t)i, BlockSize );
		}
		
		CHECK( poolAllocator.Allocate() == NULL );

		for ( int i = 0; i < NumBlocks; ++i )
		{
			for ( int j = 0; j < BlockSize; ++j )
				CHECK( *(ptrs[i]+j) == uint8_t(i) );
		}
		
		for ( int i = 0; i < NumBlocks; ++i )
		{
			poolAllocator.Free( ptrs[i] );
		}

		for ( int i = 0; i < NumBlocks; ++i )
		{
			ptrs[i] = (uint8_t*) poolAllocator.Allocate();
			CHECK( ptrs[i] );
			memset( ptrs[i], (uint8_t)i, BlockSize );
		}

		for ( int i = 0; i < NumBlocks; ++i )
		{
			for ( int j = 0; j < BlockSize; ++j )
				CHECK( *(ptrs[i]+j) == uint8_t(i) );
		}
	}
	
	struct Event
	{
		int id;
	};
	
	TEST( test_util_queue )
	{
		const int MemSize = 1024 * 10;
		const int BlockSize = 256;
		const int NumReps = 100;
		
		PoolAllocator poolAllocator( MemSize, BlockSize );

		Queue<Event> queue;
        queue.Initialize( poolAllocator );
		
		for ( int rep = 0; rep < NumReps; ++rep )
		{
			CHECK( queue.GetCount() == 0 );
			CHECK( queue.Pop() == NULL );
		
			int count = rand() % 1000 + 100;
			for ( int i = 0; i < count ; ++i )
			{
				Event * event = new Event();
				event->id = i;
				CHECK( queue.GetCount() == i );
				queue.Push( event );
				CHECK( queue.GetCount() == i + 1 );
			}
		
			int id = 0;
			while ( Event * event = queue.Pop() )
			{
				CHECK( event->id == id );
				id++;
			}
			CHECK( id == count );
		
			CHECK( queue.GetCount() == 0 );
			
			CHECK( poolAllocator.GetUsedBytes() == 0 );
			CHECK( poolAllocator.GetFreeBytes() == poolAllocator.GetTotalBytes() );
		}
	}

    TEST( test_compact_allocator )
    {
        const int NumBlocks = 256;
        const int TotalSize = 1024 * 1024;

        CompactAllocator compactAllocator( NumBlocks, TotalSize );

        // allocate max # of blocks

        int allocated = 0;
        for ( int i = 0; i < NumBlocks; ++i )
        {
            int bytes = ( i + 10 ) * 16;
            uint8_t * block = compactAllocator.AllocateBlock( i, bytes );
            CHECK( block );
            memset( block, i, bytes );

            allocated += bytes;
            CHECK( compactAllocator.GetUsedBytes() == allocated );
            CHECK( compactAllocator.GetFreeBytes() == compactAllocator.GetTotalBytes() - compactAllocator.GetUsedBytes() );
        }

        // verify that all blocks maintain correct memory and sizes

        for ( int i = 0; i < NumBlocks; ++i )
        {
            int expectedBytes = ( i + 10 ) * 16;
            int bytes = compactAllocator.GetBlockSize( i );
            uint8_t * block = compactAllocator.GetBlockPtr( i );
            CHECK( block );
            CHECK( bytes == expectedBytes );
            for ( int j = 0; j < bytes; ++j )
                CHECK( block[j] == i );
        }

        // free some random blocks

        compactAllocator.FreeBlock( 0 );
        compactAllocator.FreeBlock( NumBlocks / 2 );
        compactAllocator.FreeBlock( NumBlocks - 1 );

        // verify that all of the remaining blocks match what we expected

        for ( int i = 0; i < NumBlocks; ++i )
        {
            int expectedBytes = ( i + 10 ) * 16;
            int bytes = compactAllocator.GetBlockSize( i );
            uint8_t * block = compactAllocator.GetBlockPtr( i );
            if ( block )
            {
                CHECK( bytes == expectedBytes );
                for ( int j = 0; j < bytes; ++j )
                    CHECK( block[j] == i );
            }
        }

        // now free all the remaining blocks

        for ( int i = 0; i < NumBlocks; ++i )
        {
            if ( compactAllocator.GetBlockPtr( i ) )
                compactAllocator.FreeBlock( i );
        }

        CHECK( compactAllocator.GetUsedBytes() == 0 );
        CHECK( compactAllocator.GetFreeBytes() == compactAllocator.GetTotalBytes() );
    }
}
