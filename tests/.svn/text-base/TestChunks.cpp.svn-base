/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netStream.h"
#include "network/netChunks.h"

using namespace net;

SUITE( NetChunks )
{
	class TestChunkConfig : public ChunkConfig
	{
	public:
		
		TestChunkConfig()
		{
			strcpy( channelConfigs[0].name, "A" );
			strcpy( channelConfigs[1].name, "B" );
			strcpy( channelConfigs[2].name, "C" );
		}
	
		const ChunkChannelConfig * GetChunkChannelConfigs( int & numChannels ) const
		{
			numChannels = 3;
			return channelConfigs;
		}
		
		ChunkChannelConfig channelConfigs[3];
	};
	
	TEST( test_chunk_initial_conditions )
	{
		TestChunkConfig chunkConfig;
		ChunkQueue chunkQueue ( chunkConfig );

		CHECK( chunkQueue.GetNumChannels() == 3 );

		for ( int channelId = 0; channelId < chunkQueue.GetNumChannels(); ++channelId )
		{
			CHECK( chunkQueue.IsSending( channelId ) == false );
			CHECK( chunkQueue.SendCompleted( channelId ) == false );
			CHECK( chunkQueue.GetSendProgressPercent( channelId ) == 0.0f );

			CHECK( chunkQueue.IsReceiving( channelId ) == false );
			CHECK( chunkQueue.ReceiveCompleted( channelId ) == false );
			CHECK( chunkQueue.GetReceiveProgressPercent( channelId ) == 0.0f );

			uint8_t dummy[256];
			int bytes = 256;
			CHECK( chunkQueue.Receive( channelId, dummy, bytes ) == false );
		}
	}

	TEST( test_chunk_send )
	{
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue chunkQueue ( chunkConfig );

		CHECK( chunkQueue.GetNumChannels() == 3 );

 		uint8_t chunk[1000];
		for ( int i = 0; i < (int) sizeof(chunk); ++i )
			chunk[i] = (uint8_t) ( rand() % 256 );

		chunkQueue.Send( ChannelId, chunk, sizeof( chunk ) );

		CHECK( chunkQueue.IsSending( ChannelId ) );
		CHECK( !chunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( chunkQueue.GetSendProgressPercent( ChannelId ), 0.0f, 0.001f );

		uint16_t sequence = 0;
		while ( !chunkQueue.SendCompleted( ChannelId ) )
		{
			chunkQueue.Update( timeBase );
			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
			Stream stream( Stream::Write, data, PacketSize, journal, JournalSize );
			bool result = chunkQueue.SerializePacket( stream, sequence );
			CHECK( result );
			if ( result )
			{
				chunkQueue.CommitPacket();
				chunkQueue.ProcessAck( sequence );
				sequence++;
			}
			else
				chunkQueue.DiscardPacket();
            timeBase.time += timeBase.deltaTime;
		}

		CHECK( !chunkQueue.IsSending( ChannelId ) );
		CHECK( chunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( chunkQueue.GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );
	}
	
	TEST( test_chunk_send_and_receive )
	{
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue ( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );

		uint8_t send_chunk[1000];
 		uint8_t recv_chunk[1000];
		memset( recv_chunk, 0, sizeof(recv_chunk) );
		for ( int i = 0; i < (int) sizeof(send_chunk); ++i )
			send_chunk[i] = (uint8_t) ( rand() % 256 );

		sendChunkQueue.Send( ChannelId, send_chunk, sizeof( send_chunk ) );

		CHECK( sendChunkQueue.IsSending( ChannelId ) );
		CHECK( !sendChunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 0.0f, 0.001f );

		uint16_t sequence = 0;
		while ( !sendChunkQueue.SendCompleted( ChannelId ) || !receiveChunkQueue.ReceiveCompleted( ChannelId ) )
		{
			sendChunkQueue.Update( timeBase );
			receiveChunkQueue.Update( timeBase );

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
			Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
			bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
			CHECK( write_result );
			if ( write_result )
				sendChunkQueue.CommitPacket();
			
			Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
			bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
			CHECK( read_result );
			if ( read_result )
				sendChunkQueue.ProcessAck( sequence );
				
			sequence++;

            timeBase.time += timeBase.deltaTime;
		}

		CHECK( !sendChunkQueue.IsSending( ChannelId ) );
		CHECK( sendChunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );

		CHECK( receiveChunkQueue.IsReceiving( ChannelId ) );
		CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );

		int bytes = sizeof(recv_chunk);
		CHECK( receiveChunkQueue.Receive( ChannelId, recv_chunk, bytes ) );
		CHECK( bytes == sizeof(recv_chunk) );
		CHECK( memcmp( recv_chunk, send_chunk, sizeof(recv_chunk) ) == 0 );

		CHECK( !receiveChunkQueue.IsReceiving( ChannelId ) );
		CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );
	}
	
	TEST( test_chunk_send_and_receive_with_packet_loss )
	{
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );
		
		uint8_t send_chunk[1000];
 		uint8_t recv_chunk[1000];
		memset( recv_chunk, 0, sizeof(recv_chunk) );
		for ( int i = 0; i < (int) sizeof(send_chunk); ++i )
			send_chunk[i] = (uint8_t) ( rand() % 256 );

		sendChunkQueue.Send( ChannelId, send_chunk, sizeof( send_chunk ) );

		CHECK( sendChunkQueue.IsSending( ChannelId ) );
		CHECK( !sendChunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 0.0f, 0.001f );

		uint16_t sequence = 0;
		while ( !sendChunkQueue.SendCompleted( ChannelId ) || !receiveChunkQueue.ReceiveCompleted( ChannelId ) )
		{
			sendChunkQueue.Update( timeBase );
			receiveChunkQueue.Update( timeBase );

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
			Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
			bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
			CHECK( write_result );
			if ( write_result )
				sendChunkQueue.CommitPacket();

			if ( ( rand() % 20 ) == 0 )
			{			
				Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
				bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
				CHECK( read_result );
				if ( read_result )
					sendChunkQueue.ProcessAck( sequence );
			}
				
			sequence++;

            timeBase.time += timeBase.deltaTime;
		}

		CHECK( !sendChunkQueue.IsSending( ChannelId ) );
		CHECK( sendChunkQueue.SendCompleted( ChannelId ) );
		CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );

		CHECK( receiveChunkQueue.IsReceiving( ChannelId ) );
		CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );

		int bytes = sizeof(recv_chunk);
		CHECK( receiveChunkQueue.Receive( ChannelId, recv_chunk, bytes ) );
		CHECK( bytes == sizeof(recv_chunk) );
		CHECK( memcmp( recv_chunk, send_chunk, sizeof(recv_chunk) ) == 0 );

		CHECK( !receiveChunkQueue.IsReceiving( ChannelId ) );
		CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );
	}
	
	TEST( test_chunk_repeated_send_and_receive )
	{
		const int RepeatCount = 10;
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );

		uint16_t sequence = 0;

		for ( int i = 0; i < RepeatCount; ++i )
		{
			uint8_t send_chunk[1000];
	 		uint8_t recv_chunk[1000];
			memset( recv_chunk, 0, sizeof(recv_chunk) );
			for ( int i = 0; i < (int) sizeof(send_chunk); ++i )
				send_chunk[i] = (uint8_t) ( rand() % 256 );

			sendChunkQueue.Send( ChannelId, send_chunk, sizeof( send_chunk ) );

			CHECK( sendChunkQueue.IsSending( ChannelId ) );
			CHECK( !sendChunkQueue.SendCompleted( ChannelId ) );
			CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 0.0f, 0.001f );

			while ( !sendChunkQueue.SendCompleted( ChannelId ) || !receiveChunkQueue.ReceiveCompleted( ChannelId ) )
			{
				sendChunkQueue.Update( timeBase );
				receiveChunkQueue.Update( timeBase );

				uint8_t data[PacketSize];
				uint8_t journal[JournalSize];
				Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
				bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
				CHECK( write_result );
				if ( write_result )
					sendChunkQueue.CommitPacket();
			
				Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
				bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
				CHECK( read_result );
				if ( read_result )
					sendChunkQueue.ProcessAck( sequence );
				
				sequence++;

                timeBase.time += timeBase.deltaTime;
            }
			
			CHECK( !sendChunkQueue.IsSending( ChannelId ) );
			CHECK( sendChunkQueue.SendCompleted( ChannelId ) );
			CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );

			CHECK( receiveChunkQueue.IsReceiving( ChannelId ) );
			CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );

			int bytes = sizeof(recv_chunk);
			CHECK( receiveChunkQueue.Receive( ChannelId, recv_chunk, bytes ) );
			CHECK( bytes == sizeof(recv_chunk) );
			CHECK( memcmp( recv_chunk, send_chunk, sizeof(recv_chunk) ) == 0 );

			CHECK( !receiveChunkQueue.IsReceiving( ChannelId ) );
			CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );
		}
	}
	
	template <int size> struct ChunkData
	{
		ChunkData()
		{
			NET_ASSERT( size > 0 );
			chunk_size = rand() % size;
			if ( chunk_size == 0 )
				chunk_size = 1;
			for ( int i = 0; i < chunk_size; ++i )
				send_chunk[i] = (uint8_t) ( rand() % 256 );
			memset( recv_chunk, 0, chunk_size );
		}
		int chunk_size;
		uint8_t send_chunk[size];
		uint8_t recv_chunk[size];
	};

	TEST( test_chunk_send_queue )
	{
		const int ChunkSize = 1000;
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );

		const int SendQueueSize = chunkConfig.channelConfigs[0].sendQueueSize;

		uint16_t sequence = 0;

		ChunkData<ChunkSize> * chunkData = new ChunkData<ChunkSize>[SendQueueSize];

		for ( int i = 0; i < SendQueueSize; ++i )
			sendChunkQueue.Send( ChannelId, chunkData[i].send_chunk, chunkData[i].chunk_size );

		CHECK( sendChunkQueue.IsSending( ChannelId ) );
		CHECK( !sendChunkQueue.SendCompleted( ChannelId ) );

		int chunksReceived = 0;
		while ( chunksReceived < SendQueueSize )
		{
			sendChunkQueue.Update( timeBase );
			receiveChunkQueue.Update( timeBase );

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
			Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
			bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
			CHECK( write_result );
			if ( write_result )
				sendChunkQueue.CommitPacket();
		
			Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
			bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
			CHECK( read_result );
			if ( read_result )
				sendChunkQueue.ProcessAck( sequence );
			
			int bytes = ChunkSize;
			if ( receiveChunkQueue.Receive( ChannelId, chunkData[chunksReceived].recv_chunk, bytes ) )
			{
				CHECK( bytes == chunkData[chunksReceived].chunk_size );
				CHECK( memcmp( chunkData[chunksReceived].recv_chunk, chunkData[chunksReceived].send_chunk, bytes ) == 0 );
				chunksReceived++;
			}
			
			sequence++;

            timeBase.time += timeBase.deltaTime;
		}
		
		delete [] chunkData;
	}

	TEST( test_chunk_channels )
	{
		const int NumChannels = 3;
		const int ChunkSize = 1000;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );

		uint16_t sequence = 0;

		ChunkData<ChunkSize> * chunkData = new ChunkData<ChunkSize>[NumChannels];

		for ( int i = 0; i < NumChannels; ++i )
		{
			sendChunkQueue.Send( i, chunkData[i].send_chunk, chunkData[i].chunk_size );
			CHECK( sendChunkQueue.IsSending( i ) );
			CHECK( !sendChunkQueue.SendCompleted( i ) );
		}

		int chunksReceived = 0;
		while ( chunksReceived < NumChannels )
		{
			sendChunkQueue.Update( timeBase );
			receiveChunkQueue.Update( timeBase );

			uint8_t data[PacketSize];
			uint8_t journal[JournalSize];
			Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
			bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
			CHECK( write_result );
			if ( write_result )
				sendChunkQueue.CommitPacket();
		
			Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
			bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
			CHECK( read_result );
			if ( read_result )
				sendChunkQueue.ProcessAck( sequence );

			for ( int i = 0; i < NumChannels; ++i )
			{
				int bytes = ChunkSize;
 				if ( receiveChunkQueue.Receive( i, chunkData[i].recv_chunk, bytes ) )
				{
					// note: chunks should be received in channel order
					// lower channel ids block higher channel id from send until completed
					CHECK( i == chunksReceived );
					CHECK( bytes == chunkData[i].chunk_size );
					CHECK( memcmp( chunkData[i].recv_chunk, chunkData[i].send_chunk, bytes ) == 0 );
					chunksReceived++;
				}
			}

			sequence++;

            timeBase.time += timeBase.deltaTime;
		}
		
		CHECK( chunksReceived == NumChannels );
		
		delete [] chunkData;
	}
	
	TEST( test_chunk_packet_loss )
	{
		const int RepeatCount = 10;
		const int ChannelId = 0;
		const int PacketSize = 1024;
		const int JournalSize = 1024;
		const float DeltaTime = 0.1f;

        net::TimeBase timeBase;
        timeBase.deltaTime = SecondsToNetworkTime( DeltaTime );

		TestChunkConfig chunkConfig;
		ChunkQueue sendChunkQueue( chunkConfig );
		ChunkQueue receiveChunkQueue( chunkConfig );

		uint16_t sequence = 0;

		for ( int i = 0; i < RepeatCount; ++i )
		{
			uint8_t send_chunk[1000];
	 		uint8_t recv_chunk[1000];
			memset( recv_chunk, 0, sizeof(recv_chunk) );
			for ( int i = 0; i < (int) sizeof(send_chunk); ++i )
				send_chunk[i] = (uint8_t) ( rand() % 256 );

			sendChunkQueue.Send( ChannelId, send_chunk, sizeof( send_chunk ) );

			CHECK( sendChunkQueue.IsSending( ChannelId ) );
			CHECK( !sendChunkQueue.SendCompleted( ChannelId ) );
			CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 0.0f, 0.001f );

			while ( !sendChunkQueue.SendCompleted( ChannelId ) || !receiveChunkQueue.ReceiveCompleted( ChannelId ) )
			{
				sendChunkQueue.Update( timeBase );
				receiveChunkQueue.Update( timeBase );

				uint8_t data[PacketSize];
				uint8_t journal[JournalSize];
				Stream write_stream( Stream::Write, data, PacketSize, journal, JournalSize );
				bool write_result = sendChunkQueue.SerializePacket( write_stream, sequence );
				CHECK( write_result );
				
				bool dropPacket = ( rand() % 2 ) == 0;
				if ( !dropPacket )
				{
					sendChunkQueue.CommitPacket();
			
					Stream read_stream( Stream::Read, data, PacketSize, journal, JournalSize );
					bool read_result = receiveChunkQueue.SerializePacket( read_stream, sequence );
					CHECK( read_result );
					if ( read_result )
						sendChunkQueue.ProcessAck( sequence );
				}
				else
				{
					sendChunkQueue.DiscardPacket();
				}
				
				sequence++;

                timeBase.time += timeBase.deltaTime;
            }
			
			CHECK( !sendChunkQueue.IsSending( ChannelId ) );
			CHECK( sendChunkQueue.SendCompleted( ChannelId ) );
			CHECK_CLOSE( sendChunkQueue.GetSendProgressPercent( ChannelId ), 100.0f, 0.001f );

			CHECK( receiveChunkQueue.IsReceiving( ChannelId ) );
			CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );

			int bytes = sizeof(recv_chunk);
			CHECK( receiveChunkQueue.Receive( ChannelId, recv_chunk, bytes ) );
			CHECK( bytes == sizeof(recv_chunk) );
			CHECK( memcmp( recv_chunk, send_chunk, sizeof(recv_chunk) ) == 0 );

			CHECK( !receiveChunkQueue.IsReceiving( ChannelId ) );
			CHECK( receiveChunkQueue.ReceiveCompleted( ChannelId ) );
		}
	}
}
