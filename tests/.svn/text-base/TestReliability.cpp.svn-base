/*****************************************************************************
 * Networking Library by Glenn Fiedler <gaffer@gaffer.org>
 * Copyright (c) Sony Computer Entertainment America 2008-2010
 ****************************************************************************/

#include "PreCompiled.h"
#include "network/netReliability.h"
#include "network/netSockets.h"

using namespace net;

SUITE( NetReliability )
{
	TEST( test_reliability_generate_ack_bits )
	{
		PacketQueue packetQueue;
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = packetQueue.Add( i );
			entry->sequence = i;
		}
		CHECK( ReliabilitySystem::generate_ack_bits( 31, packetQueue ) == 0xFFFFFFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 30, packetQueue ) == 0x7FFFFFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 32, packetQueue ) == 0xFFFFFFFE );
		CHECK( ReliabilitySystem::generate_ack_bits( 15, packetQueue ) == 0x0000FFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 47, packetQueue ) == 0xFFFF0000 );
	}

	TEST( test_reliability_generate_ack_bits_with_wrap )
	{
		PacketQueue packetQueue;
		packetQueue.Rebase( 65535 - 32 );
		for ( int i = 65535 - 31; i <= 65535; ++i )
		{
			ReliabilityQueueEntry * entry = packetQueue.Add( i );
			entry->sequence = i;
		}
		CHECK( ReliabilitySystem::generate_ack_bits( 0, packetQueue ) == 0xFFFFFFFE );
		CHECK( ReliabilitySystem::generate_ack_bits( 65535, packetQueue ) == 0xFFFFFFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 65534, packetQueue ) == 0x7FFFFFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 65535 - 16, packetQueue ) == 0x0000FFFF );
		CHECK( ReliabilitySystem::generate_ack_bits( 15, packetQueue ) == 0xFFFF0000 );
	}
	
	TEST( test_reliability_process_ack_1 )
	{
		PacketQueue pendingAckQueue;
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( i );
			entry->sequence = i;
		}
		PacketQueue ackedQueue;
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, 31, 0xFFFFFFFF, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 32 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
			acked[acks[i]] = true;
		for ( int i = 0; i < 32; ++i )
		{
			CHECK( acked[i] == true );
			ReliabilityQueueEntry * entry = ackedQueue.Get( i );
			CHECK( entry && entry->sequence == i );
		}
	}

	TEST( test_reliability_process_ack_2 )
	{
		PacketQueue pendingAckQueue;
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( i );
			entry->sequence = i;
		}
		PacketQueue ackedQueue;
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, 31, 0x0000FFFF, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 16 );
		CHECK( ackedQueue.GetCount() == 16 );
		CHECK( pendingAckQueue.GetCount() == 32 - 16 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
			acked[acks[i]] = true;
		for ( int i = 0; i < 32; ++i )
		{
			if ( i < 16 )
			{
				CHECK( !acked[i] );
			}
			else
			{
				CHECK( acked[i] );
			}
		}
	}

	TEST( test_reliability_process_ack_3 )
	{
		PacketQueue pendingAckQueue;
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( i );
			entry->sequence = i;
		}
		PacketQueue ackedQueue;
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, 47, 0xFFFF0000, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 16 );
		CHECK( ackedQueue.GetCount() == 16 );
		CHECK( pendingAckQueue.GetCount() == 16 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
			acked[acks[i]] = true;
		for ( int i = 0; i < 32; ++i )
		{
			if ( i < 16 || i == 32 )
			{
				CHECK( !acked[i] );
			}
			else
			{
				CHECK( acked[i] );
			}
		}
	}

	TEST( test_reliability_process_ack_wrap_around_1 )
	{
		const int base = 65530;
		PacketQueue pendingAckQueue;
		pendingAckQueue.Rebase( base );
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( base + i );
			NET_ASSERT( entry );
			entry->sequence = base + i;
		}
		PacketQueue ackedQueue;
		ackedQueue.Rebase( base );
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, uint16_t(base+31), 0xFFFFFFFF, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 32 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
		{
			int index = acks[i] < base ? ( acks[i] + 65536 - base ) : acks[i] - base;
			NET_ASSERT( index >= 0 );
			NET_ASSERT( index < 32 );
			acked[index] = true;
		}
		for ( int i = 0; i < 32; ++i )
			CHECK( acked[i] == true );
	}

	TEST( test_reliability_process_ack_wrap_around_2 )
	{
		const int base = 65530;
		PacketQueue pendingAckQueue;
		pendingAckQueue.Rebase( base );
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( i + base );
			entry->sequence = i + base;
		}
		PacketQueue ackedQueue;
		ackedQueue.Rebase( base );
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, uint16_t(base+31), 0x0000FFFF, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 16 );
		CHECK( ackedQueue.GetCount() == 16 );
		CHECK( pendingAckQueue.GetCount() == 16 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
		{
			int index = acks[i] < base ? ( acks[i] + 65536 - base ) : acks[i] - base;
			NET_ASSERT( index >= 0 );
			NET_ASSERT( index < 32 );
			acked[index] = true;
		}
		for ( int i = 0; i < 32; ++i )
		{
			if ( i < 16 )
			{
				CHECK( !acked[i] );
			}
			else
			{
				CHECK( acked[i] );
			}
		}
	}

	TEST( test_reliability_process_ack_wrap_around_3 )
	{
		const int base = 65530;
		PacketQueue pendingAckQueue;
		pendingAckQueue.Rebase( base );
		for ( int i = 0; i < 32; ++i )
		{
			ReliabilityQueueEntry * entry = pendingAckQueue.Add( i + base );
			entry->sequence = i + base;
		}
		PacketQueue ackedQueue;
		ackedQueue.Rebase( base );
		uint16_t acks[32];
		float rtt = 0.0f;
		int acked_packets = 0;
		ReliabilitySystem::process_ack( 0, uint16_t(base+47), 0xFFFF0000, pendingAckQueue, ackedQueue, acks, acked_packets, rtt );
		CHECK( acked_packets == 16 );
		CHECK( ackedQueue.GetCount() == 16 );
		CHECK( pendingAckQueue.GetCount() == 16 );
		bool acked[32];
		memset( acked, 0, sizeof(acked) );
		for ( int i = 0; i < acked_packets; ++i )
		{
			int index = acks[i] < base ? ( acks[i] + 65536 - base ) : acks[i] - base;
			NET_ASSERT( index >= 0 );
			NET_ASSERT( index < 32 );
			acked[index] = true;
		}
		for ( int i = 0; i < 32; ++i )
		{
			if ( i < 16 || i == 32 )
			{
				CHECK( !acked[i] );
			}
			else
			{
				CHECK( acked[i] );
			}
		}
	}
}
